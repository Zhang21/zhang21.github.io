<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>人工智能 - 风继续吹</title><meta name="Description" content="个人博客"><meta property="og:title" content="人工智能" />
<meta property="og:description" content="微软人工智能课程的笔记。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhang21.cn/ai-for-beginners/" /><meta property="og:image" content="https://zhang21.cn/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-31T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2024-03-31T00:00:00&#43;00:00" /><meta property="og:site_name" content="My cool site" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://zhang21.cn/logo.png"/>

<meta name="twitter:title" content="人工智能"/>
<meta name="twitter:description" content="微软人工智能课程的笔记。"/>
<meta name="application-name" content="风继续吹">
<meta name="apple-mobile-web-app-title" content="风继续吹"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://zhang21.cn/ai-for-beginners/" /><link rel="prev" href="https://zhang21.cn/postgresql/" /><link rel="next" href="https://zhang21.cn/generative-ai/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "人工智能",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/zhang21.cn\/ai-for-beginners\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "https:\/\/zhang21.cn\/images\/Apple-Devices-Preview.png",
                            "width":  3200 ,
                            "height":  2048 
                        }],"genre": "posts","keywords": "AI, 人工智能","wordcount":  21510 ,
        "url": "https:\/\/zhang21.cn\/ai-for-beginners\/","datePublished": "2024-03-31T00:00:00+00:00","dateModified": "2024-03-31T00:00:00+00:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Zhang21","logo": "https:\/\/zhang21.cn\/leslie.png"},"author": {
                "@type": "Person",
                "name": "Zhang21"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="风继续吹"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>风继续吹</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/" title="所有文章"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/zhang21" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="风继续吹"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>风继续吹</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="所有文章">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/zhang21" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">人工智能</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://zhang21.cn" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Zhang21</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/ai/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>AI</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2024-03-31">2024-03-31</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 21510 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 43 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#术语表">术语表</a></li>
    <li><a href="#初学者的人工智能">初学者的人工智能</a></li>
    <li><a href="#人工智能简介">人工智能简介</a>
      <ul>
        <li><a href="#课前测试">课前测试</a></li>
        <li><a href="#弱ai和强ai">弱AI和强AI</a></li>
        <li><a href="#智能的定义和图灵测试">智能的定义和图灵测试</a></li>
        <li><a href="#ai的不同方法">AI的不同方法</a>
          <ul>
            <li><a href="#自上而下法">自上而下法</a></li>
            <li><a href="#自下而上法">自下而上法</a></li>
          </ul>
        </li>
        <li><a href="#ai简史">AI简史</a></li>
        <li><a href="#最新的ai研究">最新的AI研究</a></li>
      </ul>
    </li>
    <li><a href="#知识表示和专家系统">知识表示和专家系统</a>
      <ul>
        <li><a href="#知识表示">知识表示</a></li>
        <li><a href="#计算机知识表示分类">计算机知识表示分类</a></li>
        <li><a href="#专家系统">专家系统</a>
          <ul>
            <li><a href="#前向推理与反向推理">前向推理与反向推理</a></li>
            <li><a href="#练习-动物推理">练习-动物推理</a></li>
          </ul>
        </li>
        <li><a href="#本体和语义网">本体和语义网</a>
          <ul>
            <li><a href="#练习-家庭本体论">练习-家庭本体论</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#神经网络简介-感知器">神经网络简介-感知器</a>
      <ul>
        <li><a href="#感知器模型">感知器模型</a></li>
        <li><a href="#训练感知器">训练感知器</a></li>
      </ul>
    </li>
    <li><a href="#神经网络简介-多层感知器">神经网络简介-多层感知器</a>
      <ul>
        <li><a href="#机器学习的形式化">机器学习的形式化</a></li>
        <li><a href="#梯度下降优化">梯度下降优化</a></li>
        <li><a href="#多层感知器和反向传播">多层感知器和反向传播</a></li>
      </ul>
    </li>
    <li><a href="#神经网络框架">神经网络框架</a>
      <ul>
        <li><a href="#过拟合">过拟合</a>
          <ul>
            <li><a href="#为什么会发生过拟合">为什么会发生过拟合</a></li>
            <li><a href="#如何检测过拟合">如何检测过拟合</a></li>
            <li><a href="#如何阻止过拟合">如何阻止过拟合</a></li>
            <li><a href="#偏差-方差权衡">偏差-方差权衡</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#计算机视觉">计算机视觉</a></li>
    <li><a href="#计算机视觉入门">计算机视觉入门</a>
      <ul>
        <li><a href="#使用计算机视觉的示例">使用计算机视觉的示例</a></li>
      </ul>
    </li>
    <li><a href="#卷积神经网络">卷积神经网络</a>
      <ul>
        <li><a href="#卷积神经网络背后的主要理念">卷积神经网络背后的主要理念</a></li>
        <li><a href="#金字塔架构">金字塔架构</a></li>
      </ul>
    </li>
    <li><a href="#著名的卷积网络神经架构">著名的卷积网络神经架构</a>
      <ul>
        <li><a href="#vgg-16架构">VGG-16架构</a></li>
        <li><a href="#resnet架构">ResNet架构</a></li>
        <li><a href="#inception架构">Inception架构</a></li>
        <li><a href="#mobilenet">MobileNet</a></li>
      </ul>
    </li>
    <li><a href="#预训练网络和迁移学习">预训练网络和迁移学习</a>
      <ul>
        <li><a href="#作为特征提取器的预训练模型">作为特征提取器的预训练模型</a></li>
        <li><a href="#练习-迁移学习">练习-迁移学习</a></li>
        <li><a href="#可视化对抗猫">可视化对抗猫</a></li>
      </ul>
    </li>
    <li><a href="#深度学习训练技巧">深度学习训练技巧</a>
      <ul>
        <li><a href="#将数值保持在合理区间">将数值保持在合理区间</a></li>
        <li><a href="#初始权重初始化">初始权重初始化</a></li>
        <li><a href="#批量归一化">批量归一化</a></li>
        <li><a href="#dropout">Dropout</a></li>
        <li><a href="#防止过度拟合">防止过度拟合</a></li>
        <li><a href="#优化器和训练算法">优化器和训练算法</a></li>
        <li><a href="#不同的网络架构">不同的网络架构</a></li>
      </ul>
    </li>
    <li><a href="#自动编码器">自动编码器</a>
      <ul>
        <li><a href="#自动编码器的使用场景">自动编码器的使用场景</a></li>
        <li><a href="#变异自动编码器">变异自动编码器</a></li>
        <li><a href="#自动编码器的特性">自动编码器的特性</a></li>
      </ul>
    </li>
    <li><a href="#生成式对抗网络">生成式对抗网络</a>
      <ul>
        <li><a href="#判别器">判别器</a></li>
        <li><a href="#生成器">生成器</a></li>
        <li><a href="#训练生成式对抗网络">训练生成式对抗网络</a></li>
        <li><a href="#生成式对抗网络训练的问题">生成式对抗网络训练的问题</a></li>
        <li><a href="#风格转换">风格转换</a></li>
      </ul>
    </li>
    <li><a href="#物体检测">物体检测</a>
      <ul>
        <li><a href="#物体检测的原生方法">物体检测的原生方法</a></li>
        <li><a href="#物体检测回归">物体检测回归</a></li>
        <li><a href="#物体检测数据集">物体检测数据集</a></li>
        <li><a href="#物体检测指标">物体检测指标</a></li>
        <li><a href="#不同的物体检测方法">不同的物体检测方法</a></li>
      </ul>
    </li>
    <li><a href="#分割算法">分割算法</a>
      <ul>
        <li><a href="#医学影像分割">医学影像分割</a></li>
      </ul>
    </li>
    <li><a href="#自然语言处理">自然语言处理</a></li>
    <li><a href="#用张量表示文本">用张量表示文本</a>
      <ul>
        <li><a href="#文本分类">文本分类</a></li>
        <li><a href="#表示文本">表示文本</a></li>
        <li><a href="#n元组">N元组</a></li>
        <li><a href="#词袋">词袋</a></li>
      </ul>
    </li>
    <li><a href="#语义词嵌入">语义词嵌入</a>
      <ul>
        <li><a href="#语义嵌入-word2vec">语义嵌入-Word2Vec</a></li>
        <li><a href="#上下文嵌入">上下文嵌入</a></li>
      </ul>
    </li>
    <li><a href="#语言模型">语言模型</a>
      <ul>
        <li><a href="#训练嵌入">训练嵌入</a></li>
      </ul>
    </li>
    <li><a href="#循环神经网络">循环神经网络</a>
      <ul>
        <li><a href="#rnn单元剖析">RNN单元剖析</a></li>
        <li><a href="#长短期记忆">长短期记忆</a></li>
        <li><a href="#双向和多层rnn">双向和多层RNN</a></li>
      </ul>
    </li>
    <li><a href="#生成式循环网络">生成式循环网络</a>
      <ul>
        <li><a href="#软文本生成和温度">软文本生成和温度</a></li>
      </ul>
    </li>
    <li><a href="#注意力机制和变换器模型">注意力机制和变换器模型</a>
      <ul>
        <li><a href="#变换器模型">变换器模型</a>
          <ul>
            <li><a href="#位置编码">位置编码</a></li>
            <li><a href="#多头自我注意力">多头自我注意力</a></li>
            <li><a href="#编码器-解码器注意力">编码器-解码器注意力</a></li>
          </ul>
        </li>
        <li><a href="#bert">BERT</a></li>
      </ul>
    </li>
    <li><a href="#命名实体识别">命名实体识别</a>
      <ul>
        <li><a href="#ner使用示例">NER使用示例</a></li>
        <li><a href="#作为词块分类的ner">作为词块分类的NER</a></li>
        <li><a href="#训练ner模型">训练NER模型</a></li>
      </ul>
    </li>
    <li><a href="#大语言模型和提示工程">大语言模型和提示工程</a>
      <ul>
        <li><a href="#文本生成与困惑度">文本生成与困惑度</a></li>
        <li><a href="#gpt是一个大家族">GPT是一个大家族</a></li>
        <li><a href="#提示工程">提示工程</a></li>
      </ul>
    </li>
    <li><a href="#其他ai技术">其他AI技术</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p>微软人工智能课程的笔记。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://microsoft.github.io/AI-For-Beginners/" target="_blank" rel="noopener noreffer ">MS AI for Beginners</a></li>
<li>DeepL</li>
</ul>
<br/>
<br/>
<h1 id="术语表">术语表</h1>
<p>人工智能相关的一些相关术语：</p>
<ul>
<li>人工智能（AI, Artificial Intelligence）</li>
<li>弱人工智能（Weak AI）</li>
<li>强/通用人工智能（Strong AI, AGI）</li>
<li>符号人工智能（Symbolic AI）</li>
<li>专家系统（Expert System）</li>
<li>推理引擎（inference engine）</li>
<li>神经网络（Neural Network）</li>
<li>深度学习（Deep Learning）</li>
<li>计算机视觉（Computer Vision）</li>
<li>自然语言处理（NLP, Natural Language Processing）</li>
<li>图灵测试（Turing Test）</li>
<li>人工神经网络（artificial neural network）</li>
<li>机器学习（ML, Machine Learning）</li>
<li>图形处理单元（GPU, Graphics Processing Unit）</li>
<li>过拟合（overfitting）</li>
<li>偏差（Bias）：预测值与实际平均值的差值。</li>
<li>方差（Variance）：告诉我们数据的分布。</li>
<li>卷积神经网路（CNN, convolutional neural network）</li>
<li>光流（Optical flow）</li>
<li>密集光流（Dense Optical Flow ）</li>
<li>稀疏光流（Sparse Optical Flow）</li>
<li>卷积滤波器（convolutional filter）</li>
<li>二维矩阵（2D-matrix）</li>
<li>三位张量（3D-tensor）</li>
<li>卷积核（kernel）</li>
<li>滤波器（filter）</li>
<li>矩阵（matrix）</li>
<li>预训练网络（pre-trained newtorks）</li>
<li>迁移学习（transfer learning）</li>
<li>理想图像（ideal images）</li>
<li>对抗攻击（adversarial attacks）</li>
<li>梯度消失（vanishing gradients），梯度爆炸（exploding gradients）</li>
<li>正态分布（Normal distribution）/ 高斯分布</li>
<li>批量归一化（Batch Normalization）</li>
<li>变异自动编码器（VAE, variational autoencoders）</li>
<li>自监督学习（self-supervised learning）</li>
<li>生成式对抗网络（GAN, generative adversarial network）</li>
<li>生成器（generator）</li>
<li>判别器（discriminator）</li>
<li>风格转换（style transfer）</li>
<li>物体检测（objectdetection）</li>
<li>区域建议网络（Region Proposal Network）</li>
<li>兴趣区域（Region of Interests）</li>
<li>单通道（one-pass）</li>
<li>词块、词元（token）</li>
</ul>
<br/>
<hr>
<br/>
<h1 id="初学者的人工智能">初学者的人工智能</h1>
<p>探索人工智能的世界，包括符号人工智能、神经网络、深度学习、计算机视觉、自然语言处理等多个内容。</p>
<p>你将学习：</p>
<ul>
<li>关于人工智能的不同方法，包括使用知识表示（Knowledge Representation）的推理（reasoning）的古老符号方法。</li>
<li>神经网络和深度学习是现代 AI 的核心。将使用两个最受欢迎的框架 TensorFlow 和 PyTorch 中的代码来阐述这些重要主题背后的概念。</li>
<li>处理图像和文本的神经架构。</li>
<li>不太流行的 AI 方法，如遗传算法（Genetic Algorithms）和多代理系统（Multi-Agent Systems）。</li>
</ul>
<br/>
<hr>
<br/>
<h1 id="人工智能简介">人工智能简介</h1>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-intro.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-intro.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-intro.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-intro.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-intro.png"
        title="人工智能历史" /></p>
<br/>
<br/>
<h2 id="课前测试">课前测试</h2>
<p>AI 是一门科学学科，研究如何使计算机表现出智能行为，例如做那些人类擅长的事情。</p>
<p>最初，查尔斯-巴贝奇发明的计算机安装明确定义的程序——算法，对数字进行运算。现代计算机比 19 世纪的原始模型先进得多，但仍遵循相同的受控计算理念。因此，如果我们知道实现目标所需的确切步骤顺序，就有可能对计算机进行编程。</p>
<br/>
<blockquote>
<p>根据照片确定一个人的年龄是一项无法明确编程的任务，因为我们不知道自己在做这件事时时如何在脑海中得出一个数字的。</p>
</blockquote>
<p>有些任务我们并不明确知道如何解决。例如，从一个人的照片判断年龄。因为我们见过很多不同年龄的人的例子，所以我们学会了这样做。但我们无法解释如何做到这一点，也无法编写程序让计算机做到这一点。这正是 AI 感兴趣的任务。</p>
<br/>
<br/>
<h2 id="弱ai和强ai">弱AI和强AI</h2>
<p>弱人工智能，强/通用人工智能。</p>
<table>
<thead>
<tr>
<th>Weak AI</th>
<th>Strong AI（AGI）</th>
</tr>
</thead>
<tbody>
<tr>
<td>针对特定任务或范围较小的任务，而设计和训练的人工智能系统。</td>
<td>指具有人类水平的管理和理解能力的人工智能系统。</td>
</tr>
<tr>
<td>一般没有智能，它们擅长执行预定任务，但缺乏真正的理解或意识。</td>
<td>有能力完成人类能够完成的任何智力任务，适应不同领域，并拥有某种形式的意识或自我意识。</td>
</tr>
<tr>
<td>例子包括 Siri 等虚拟助手、流媒体服务使用的推荐算法，以及为特定客户服务设计的聊天机器人。</td>
<td>实现它是一个长期目标，需要开发能够在各种任务和环境中进行推理、学习、理解和适应的系统。</td>
</tr>
<tr>
<td>弱 AI 高度专业化，不具备类似人类的认知能力，也不具备超出其狭窄领域的一般解决问题的能力。</td>
<td>目前，强 AI 还只是一个理论概念，还没有任何 AI 系统能达到这种通用智能水平。</td>
</tr>
</tbody>
</table>
<br/>
<br/>
<h2 id="智能的定义和图灵测试">智能的定义和图灵测试</h2>
<p>智能一词没有明确的定义。人们可以说智能与抽象思维或自我意识有关，但我们无法给它下一个恰当的定义。</p>
<p>在谈论通用人工智能时，我们需要有一些方法来判断我们是否创建了一个真正的智能系统。阿兰-图灵提出了一种名为“图灵测试”的方法，它也是智能的一种定义。如果人类无法在基于文本的对话中区分真人和计算机系统，那么该系统就被认为是智能的。</p>
<p>你有没有被聊天机器人骗过，以为自己在和人类说话？它是如何说服你的？</p>
<br/>
<br/>
<h2 id="ai的不同方法">AI的不同方法</h2>
<p>如果我们想让计算机的行为像人类一样，我们就需要以某种方式在计算机中模拟人类的思维方式。因此，我们需要努力了解是什么造就了人类的智慧。</p>
<p>解决这个问题有两种可能的方法：</p>
<table>
<thead>
<tr>
<th>自上而下法（Symbolic Reasoning）</th>
<th>自下而上法（Neural Networks）</th>
</tr>
</thead>
<tbody>
<tr>
<td>自上而下法是模拟人解决问题的推理方式。它包括从人的知识中提取知识，并以计算机可读的形式表示出来。还需要开发一种在计算机内部模拟推理的方法。</td>
<td>自下而上法以人脑结构为模型，由大量称为神经元的简单单元组成。每个神经元就像其输入的加权平均值，我们可以通过提供数据来训练神经元网络，从而解决有用的问题。</td>
</tr>
</tbody>
</table>
<br/>
<p>还有一些其他可能的智能的方法：</p>
<ul>
<li>新兴的、协同的或多代理的方法是基于这样一个事实，即复杂的智能行为可以通过大量简单代理的相互作用而获得。根据进化控制论，在元系统过渡过程中，智能可以从更简单的反应中产生。</li>
<li>进化方法或遗传算法是一种基于进化元里的优化过程。</li>
</ul>
<br/>
<br/>
<h3 id="自上而下法">自上而下法</h3>
<p>在此方法中，尝试对推理进行建模。由于在推理时可以跟随自己的思维，因此可以将这一过程形式化，并在计算机中进行编程。这就是所谓的符号推理。</p>
<p>人们的头脑中往往会有一些指导决策过程的规则。例如，当医生诊断病人时，他可能会意识到一个病人发烧了，因此体内可能有一些炎症。通过将大量规则应用于特定问题，医生可能会得出最终诊断结果。</p>
<p>这种方法很大程度上依赖于知识表示和推理。从人类专家那里提取知识可能是最困难的部分。因为在很多情况下，医生并不知道自己为什么会得出特定的诊断结果。有时，他只是在脑海中浮现出解决方案，而无需进行明确的思考。</p>
<br/>
<br/>
<h3 id="自下而上法">自下而上法</h3>
<p>我们可以通过模拟大脑中最简单的元素——神经元。我们可以在计算机中构建一个所谓的人工神经网络（artificial neural network），然后通过示例教它解决问题。这个过程类似于新生儿通过观察了解周围环境的过程。</p>
<p>研究一下婴儿是如何学习的。婴儿大脑的基本元素是什么？</p>
<p>机器学习是什么？人工智能的一部分是通过计算机学习来解决基于某些数据的问题，这称为机器学习（ML, Machine Learning）。请参考<a href="https://github.com/microsoft/ML-For-Beginners" target="_blank" rel="noopener noreffer ">机器学习</a>。</p>
<br/>
<br/>
<h2 id="ai简史">AI简史</h2>
<p>人工智能作为一个领域始于二十世纪中叶。最初，符号推理是一种流行的方法，并取得了一些重要的成功。然而，人们很快就发现，这种方法并不能很好地扩展。从专家那里提取知识，用计算机将其表示出来，并保持知识库的准确性，是一项非常复杂的任务，而且成本太高，在很多情况下并不实用。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/history-of-ai.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/history-of-ai.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/history-of-ai.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/history-of-ai.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/history-of-ai.png"
        title="人工智能简史" /></p>
<br/>
<p>随着时间的推移，计算资源变得越来越偏移，可用的数据也越来越多，因此神经网络方法开始在计算机视觉或语音理解等领域展现出与人类竞争的卓越性能。近十年来，人工智能一词大多被用作神经网络的同义词，因为我们听到的大多数人工智能成功案例都是基于神经网络。</p>
<p>如一个下棋程序：</p>
<ul>
<li>早期的国际象棋程序是以搜索为基础的，程序明确地产时估计对手在给定的下一步棋数中可能走的步数，并根据几步棋所能达到的最佳位置选择最佳棋步。这导致了所谓的 alpha-beta pruning  搜索算法的发展。</li>
<li>搜索策略在棋局结束时很好，因为此时需要搜索的步数很少。然而，在棋局开始时，搜索空间是巨大的，因此可以通过学习人类棋手之间的现有对局来改进算法。</li>
<li>能够战胜人类棋手的现代程序都是基于神经网络和强化学习，程序完全通过长时间与自己对弈并从自己的错误中学会下棋——这与人类学习下棋的过程非常相似。然而，计算机程序可以用更少的时间下更多的棋，因此学习速度也更快。</li>
</ul>
<br/>
<br/>
<h2 id="最新的ai研究">最新的AI研究</h2>
<p>近期神经网络研究的巨大发展始于 2010 年左右，当时大型公共数据集开始可用。</p>
<p>2012 年，卷积神经网络首次用于图像分类，使分类错误率大幅下降。</p>
<p>从那时起，神经网络在许多任务中表现都非常成功：图像分类、会话语音识别、自动机器翻译和图像字幕等。</p>
<p>在过去几年中，大模型语言取得巨大成功，如 BERT 和 GPT-3。这主要归功于有大量的通用文本数据可供使用，让我们可以训练模型来捕捉文本的结构和含义，在通用文本几何上对它们进行预训练，然后针对更具体的任务对这些模型进行专门化。我们将在后面学习自然语言处理。</p>
<br/>
<hr>
<br/>
<h1 id="知识表示和专家系统">知识表示和专家系统</h1>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-symbolic.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-symbolic.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-symbolic.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-symbolic.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-symbolic.png"
        title="符号AI" /></p>
<p>对人工智能的追求基于对知识的探求，即像人类一样理解世界。</p>
<p>符号AI基于两大理念：知识表示和推理。</p>
<p>如今，人工智能通常被认为是机器学习或神经网络的代名词。然而，人类也会进行显式推理，这时神经网络目前无法处理的。在现实世界的项目中，显式推理仍被用于执行需要解释的任务，或以受控方式修改系统行为。</p>
<br/>
<p><a href="https://red-field-0a6ddfd03.1.azurestaticapps.net/quiz/102" target="_blank" rel="noopener noreffer ">课前练习</a> 和 <a href="https://red-field-0a6ddfd03.1.azurestaticapps.net/quiz/202" target="_blank" rel="noopener noreffer ">课后练习</a></p>
<br/>
<br/>
<h2 id="知识表示">知识表示</h2>
<p>符号 AI 的一个重要概念是知识，必须将知识与信息或数据区分开。例如，书籍包含知识，人们可以通过阅读书籍成为专家。然而，书籍包含的内容实际上被称为数据，通过阅读书籍并将这些数据整合到我们的世界模型中，我们就将数据转换为了知识。</p>
<blockquote>
<p>知识使包含在我们头脑中的东西，代表着我们对世界的理解。知识是通过积极的学习过程获得的，它将我们接收到的信息碎片整合到我们对世界的积极模型中。</p>
</blockquote>
<br/>
<p>大多数情况下，我们并不严格定义知识。它包含一下概念：</p>
<ul>
<li>数据（Data）：以文字或语言等物理介质表示，独立于人类而存在，可在人与人之间传递。</li>
<li>信息（Information）：我们在头脑中解读数据的方式。</li>
<li>知识（Knowledge）：融入我们世界模型的信息。</li>
<li>智慧（Wisdom）：我们理解世界的另一个层面，它代表着知识，即关于如何以及何时使用知识的一些概念。</li>
</ul>
<br/>
<p>因此，知识表示的问题是找到某种有效的方法，以数据的形式在计算机中表示知识，使其能够自动使用。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/knowledge-spectrum.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/knowledge-spectrum.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/knowledge-spectrum.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/knowledge-spectrum.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/knowledge-spectrum.png"
        title="知识图谱" /></p>
<p>在左侧，有几种简单的知识表示法可以被计算机有效利用。最简单的是算法，即用计算机程序来表示知识。然而，这并不是最佳方式，因为它并不灵活。我们头脑中的知识往往是非算法行的。</p>
<p>在右侧，是自然文本等表征。它的功能最强大，但不能用于自动推理。</p>
<blockquote>
<p>想一想，你是如何在头脑中呈现知识并将其转化为笔记的？是否有一种特定的格式对你来说非常有效？</p>
</blockquote>
<br/>
<br/>
<h2 id="计算机知识表示分类">计算机知识表示分类</h2>
<p>我们可以将不同的计算机知识表示法分为以下几类：</p>
<ul>
<li>网络表示，基于我们大脑中存在一个由相互关联的概念组成的网络。我们可以尝试在计算机中以图形的形式再现相同的网络，即所谓的语义网络。</li>
<li>对象-属性-值或属性-值。由于图可以在计算机中表示为节点和边的列表，因此我们可以用包含对象、属性和值的三元组列表来表示语义网络。</li>
<li>分层表示，我们经常在头脑中对物体进行层次划分。例如，我们知道金丝雀是一种鸟，所有鸟都有翅膀。
<ul>
<li>框架表示，将每个对象或对象类表示为一个包含槽的框架。槽包含一些内容。所有框架形成一个层次结构，类似于面向对象编程语言中的对象层次结构。</li>
<li>情景，是一种特殊的框架，代表着可以在时间中展开的复杂情况。</li>
</ul>
</li>
<li>程序化表示，通过一些列动作来表示知识，这些动作在特定条件发生时可以执行。
<ul>
<li>生产规则是 if-then 语句，可让我们得出结论。</li>
<li>算法可被视为另一种程序表示法，尽管它们几乎从不直接用于基于知识的系统中。</li>
</ul>
</li>
<li>逻辑学，最初由亚里士多德提出，作为表述人类普遍知识的一种方法。
<ul>
<li>谓词逻辑作为一种数学理论，其内容丰富，无法计算，因此通常使用它的某些子集。</li>
<li>描述逻辑是一系列逻辑系统，用于表示和推理分布式知识表示的对象层次。</li>
</ul>
</li>
</ul>
<br/>
<p>例如，我们建立了以下有关编程语言的三元组：</p>
<table>
<thead>
<tr>
<th>Object</th>
<th>Attribute</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python</td>
<td>is</td>
<td>Untyped-Language</td>
</tr>
<tr>
<td>Untyped-Language</td>
<td>doesn&rsquo;t have</td>
<td>type definitions</td>
</tr>
</tbody>
</table>
<br/>
<table>
<thead>
<tr>
<th>Slot</th>
<th>Value</th>
<th>Default value</th>
<th>Interval</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name</td>
<td>Python</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Is-A</td>
<td>Untyped-Language</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Variable Case</td>
<td>-</td>
<td>CamelCase</td>
<td>-</td>
</tr>
<tr>
<td>Program Length</td>
<td>-</td>
<td>-</td>
<td>5-5000 lines</td>
</tr>
</tbody>
</table>
<br/>
<br/>
<h2 id="专家系统">专家系统</h2>
<p>符号人工智能的早期成功之一是所谓的专家系统，计算机系统充当某个有限问题领域的专家。它们基于从一个或多个人类专家那里提取知识库，并包含一个推理引擎，在此基础上进行推理。</p>
<p>人类神经系统的简化结构和基于知识的系统架构。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/arch-human.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/arch-human.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/arch-human.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/arch-human.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/arch-human.png"
        title="人类神经系统的简化结构" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/arch-kbs.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/arch-kbs.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/arch-kbs.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/arch-kbs.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/arch-kbs.png"
        title="基于知识的系统架构" /></p>
<br/>
<p>专家系统旧项人类的推理系统一样，包含长期记忆和短期记忆。同样，在以知识为基础的系统中，我们区分一下几个组成部分：</p>
<ul>
<li>问题记忆：包含当前正在解决的问题的相关知识。如病人的提问或血压等。这种知识也被称为静态知识，因为它包含了我们当前对问题的了解的快照——即所谓的问题状态。</li>
<li>知识库：代表有关问题领域的长期知识。它是从人类专家那里人工提取的，不会因咨询而改变。由于它允许我们从一个问题状态浏览到另一个问题状态，因此也被称为动态知识。</li>
<li>推理引擎：协调整个问题状态空间的搜索过程，必要时向用户提问。</li>
</ul>
<br/>
<p>举个例子，下面这个专家系统，它可以根据动物的身体特征来判断动物。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/AND-OR-Tree.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/AND-OR-Tree.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/AND-OR-Tree.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/AND-OR-Tree.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/AND-OR-Tree.png"
        title="AND-OR树" /></p>
<br/>
<br/>
<h3 id="前向推理与反向推理">前向推理与反向推理</h3>
<p>前向推理以工作记忆中有关问题的一些初始化数据为起点，然后执行以下推理循环：</p>
<ul>
<li>如果目标属性存在于工作记忆中，停止并给出结果。</li>
<li>查找当前条件满足的所有规则，获得冲突规则集。</li>
<li>执行冲突解决，选择一条将在此步骤中执行的规则。可能有不同的冲突解决策略：
<ul>
<li>选择知识库中第一条适用的规则</li>
<li>选择一个随机规则</li>
<li>选择一个更具体的规则</li>
</ul>
</li>
<li>应用选定的规则，在问题状态中插入新知识。</li>
<li>重复上述步骤</li>
</ul>
<br/>
<p>反向推理由目标——我们正在寻找的属性值驱动。</p>
<br/>
<br/>
<h3 id="练习-动物推理">练习-动物推理</h3>
<p>参考 <a href="https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/Animals.ipynb" target="_blank" rel="noopener noreffer ">Animals.ipynb</a>，了解实施正向和反向推理的专家系统示例。</p>
<br/>
<br/>
<h2 id="本体和语义网">本体和语义网</h2>
<p>20 世纪末，人们提出了使用知识表示法来注释互联网资源的倡议，这样就可以找到与非常具体的查询相对应的资源。这一动议被称为语义网（Semantic Web），它依赖于几个概念：</p>
<ul>
<li>一种基于描述逻辑学的特殊知识表示法。</li>
<li>分布式知识表示法，即所有概念都由一个全局 URI 标识符表示，从而创建跨越互联网的知识层次结构。</li>
<li>基于 XML 的知识描述语言系列：资源描述框架、RDF 模式、本体网络语言。</li>
</ul>
<p>语义网的一个核心概念是本提概念。它是指使用某种形式的知识表示法对问题领域进行的明确规范。最简单的本地可能只是问题领域中对象的层次结构，但更复杂的本体将包括可用于推理的规则。</p>
<br/>
<br/>
<h3 id="练习-家庭本体论">练习-家庭本体论</h3>
<p>参考 <a href="https://github.com/Ezana135/AI-For-Beginners/blob/main/lessons/2-Symbolic/FamilyOntology.ipynb" target="_blank" rel="noopener noreffer "> FamilyOntology.ipynb</a>，有关使用语义网技术推理家庭关系的示例。</p>
<br/>
<hr>
<br/>
<h1 id="神经网络简介-感知器">神经网络简介-感知器</h1>
<p>1957 年，康奈尔航空实验室的弗兰克-罗森布拉特首次尝试实现与现代神经网络类似的功能。这是一种名为 Mark-1 的硬件实现，旨在识别三角形、正方形和圆形等几何图形。</p>
<p>输入图像由 20x20 光电池阵列表示，因此神经网络有 400 个输入和一个二进制输出。一个简单的网络包含一个神经元，也称为阈值逻辑单元（threshold login unit）。神经网络的权重就像电位器，在训练阶段需要手动调整。</p>
<br/>
<p><a href="https://red-field-0a6ddfd03.1.azurestaticapps.net/quiz/103" target="_blank" rel="noopener noreffer ">课前测试</a> 和 <a href="https://red-field-0a6ddfd03.1.azurestaticapps.net/quiz/203" target="_blank" rel="noopener noreffer ">课后测试</a></p>
<br/>
<br/>
<h2 id="感知器模型">感知器模型</h2>
<p>感知器是一种二元分类模型，它可以区分输入数据的两个类别。输出结果将通过公式计算得出：$y(x)=f(w^Tx)$</p>
<br/>
<br/>
<h2 id="训练感知器">训练感知器</h2>
<p>为了训练感知器，我们需要找到一个权重向量 w，它能正确地对大部分数值进行分类，即误差最小。</p>
<br/>
<hr>
<br/>
<h1 id="神经网络简介-多层感知器">神经网络简介-多层感知器</h1>
<p>最简单的神经网络模型单层感知器，是一种线性两级分类模型。</p>
<p>本节我们将把这一模型扩展到一个更加灵活的框架中，是我们能够：</p>
<ul>
<li>进行多级分类</li>
<li>解决回归问题</li>
<li>分离不线性可分的类</li>
</ul>
<br/>
<p><a href="https://red-field-0a6ddfd03.1.azurestaticapps.net/quiz/104" target="_blank" rel="noopener noreffer ">课前测试</a> 和 <a href="https://red-field-0a6ddfd03.1.azurestaticapps.net/quiz/204" target="_blank" rel="noopener noreffer ">课后测试</a></p>
<br/>
<hr>
<br/>
<h2 id="机器学习的形式化">机器学习的形式化</h2>
<p>让我们从机器学习问题的形式化开始。假设我们有一个带有标签 Y 的训练数据集 X，我们需要建立一个能做出最准确预测的模型 f。预测的质量由损失函数（Loss Function）来衡量。经常使用的损失函数如下：</p>
<ul>
<li>对于会归问题，当我们需要预测一个数字时，可以使用绝对误差（absolute error）或平方误差（squared error）。</li>
<li>对于分类，我们使用 0-1 损失或逻辑损失。</li>
</ul>
<br/>
<br/>
<h2 id="梯度下降优化">梯度下降优化</h2>
<p>有一个著名的函数优化方法叫梯度下降法（gradient descent）。其原理是，我们可以计算损失函数相对于函数的导数（在多维情况下称为梯度），并通过改变参数来减少误差。</p>
<br/>
<br/>
<h2 id="多层感知器和反向传播">多层感知器和反向传播</h2>
<p>如上所述，单层网络能够对线性可分离的类别进行分类。为了建立更丰富的模型，我们可以将多层网络结合起来。</p>
<br/>
<br/>
<h1 id="神经网络框架">神经网络框架</h1>
<p>要想高效地训练神经网络，我们需要做两件事：</p>
<ul>
<li>对张量（tensor）进行运算</li>
<li>计算所有表达式的梯度，以便进行梯度下降优化</li>
</ul>
<br/>
<p>深度神经网络训练需要进行大量计算，因此在 GPU 上并行处理这些计算非常重要。</p>
<br/>
<p>目前最流行的两个神经框架是： TensorFlow 和 PyTorch。两者都提供了低级 API，可在 CPU 和 GPU 上对张量进行操作。</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>Low-level API</td>
<td>TensorFlow</td>
<td>Pytorch</td>
</tr>
<tr>
<td>High-level API</td>
<td>Keras</td>
<td>PyTorch Lightning</td>
</tr>
</tbody>
</table>
<p>低级 API，两个框架都允许你构建所谓的计算图。改图定义了如何在给定输入参数的情况下计算输出（通常是损失函数），如果 GPU 可用，还可以推送到 GPU 上进行计算。</p>
<p>高级 API，几乎将神经网络视为一个层序列，使大多数神经网络的构建变得更加容易。训练模型通常需要准备数据，然后调用 <code>fit</code> 函数来完成这项工作。</p>
<p>高级 API 可让你快速构建典型的神经网络，而无需担心大量细节。低级 API 对训练过程的控制能力更强，因此在研究新的神经网络架构时会被大量使用。</p>
<br/>
<br/>
<h2 id="过拟合">过拟合</h2>
<p>过拟合使机器学习中一个极其重要的概念，正确理解它非常重要。</p>
<p>在模型的丰富程度（参数数量）和训练样本数量之间取得正确的平衡非常重要。</p>
<br/>
<br/>
<h3 id="为什么会发生过拟合">为什么会发生过拟合</h3>
<ul>
<li>训练数据不足</li>
<li>模型太强大</li>
<li>输入数据噪音太大</li>
</ul>
<br/>
<br/>
<h3 id="如何检测过拟合">如何检测过拟合</h3>
<p>过拟合可通过极低的训练误差和较高的验证误差检测出来。</p>
<br/>
<br/>
<h3 id="如何阻止过拟合">如何阻止过拟合</h3>
<ul>
<li>增加训练数据量</li>
<li>降低模型的复杂度</li>
<li>使用一些正则化技术</li>
</ul>
<br/>
<br/>
<h3 id="偏差-方差权衡">偏差-方差权衡</h3>
<p>过拟合实际上是统计学中一个更普遍的问题，即偏差-方差权衡（Bias-Variance Tradeoff）。</p>
<ul>
<li>偏差错误：是由于算法无法正确捕捉训练数据之间的关系造成的。其原因可能是模型不够强大（拟合不足）。</li>
<li>方差错误：是模型逼近输入数据中的噪声而不是有意义的关系（过拟合）造成的。</li>
</ul>
<p>在训练过程中，偏差误差会减小（模型学会了逼近数据），而方差误差会增大。手动或自动停止训练对于防止过拟合非常重要。</p>
<br/>
<hr>
<br/>
<h1 id="计算机视觉">计算机视觉</h1>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-computervision.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-computervision.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-computervision.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-computervision.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-computervision.png"
        title="计算机视觉" /></p>
<br/>
<p>将了解以下内容：</p>
<ul>
<li>计算机视觉</li>
<li>卷积神经网络</li>
<li>预训练网络和迁移学习</li>
<li>自动编码器</li>
<li>生成式对抗网络</li>
<li>物体检测</li>
<li>分割</li>
</ul>
<br/>
<br/>
<h1 id="计算机视觉入门">计算机视觉入门</h1>
<p><a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89" target="_blank" rel="noopener noreffer ">计算机视觉</a>是一门学科，其目标是让计算机获得对数字图像的高级理解。这是一个相当宽泛的定义，因为理解可以有很多不同的含义，包括在图片上找到一个物体（物体检测）、理解正在发生的事情（事件检测）、用文字描述图片或重建三维场景。还有一些与人类图像相关的特殊任务：年龄和情感估计、人脸检测和识别以及三维姿态估计等。</p>
<br/>
<p>计算机视觉最简单的任务之一就是图像分类。</p>
<p>计算机视觉通常被认为是人工智能的一个分支。如今，大多数计算机视觉任务都是通过神经网络来解决的。用于计算机视觉的特殊类型神经网络——卷积神经网络。</p>
<p>不过，在将图像传递给神经网络之前，很多情况下都需要使用一些算法技术来增强图像的效果。</p>
<p>有多个可用的 Python 库用于图像处理：</p>
<ul>
<li>imageio</li>
<li>Pillow</li>
<li>OpenCV</li>
<li>dlib</li>
</ul>
<br/>
<br/>
<h2 id="使用计算机视觉的示例">使用计算机视觉的示例</h2>
<p>计算机视觉执行特定任务：</p>
<ul>
<li><strong>预处理盲文书籍的照片</strong>：重点是如何使用阈值处理、特征检测、透视变换和 NumPy 操作来分离单个盲文符号，以便神经网络进一步分类。</li>
<li><strong>利用帧差检测视频中的运动</strong>：如果摄像机是固定的，那么拍摄的帧之间应该非常相似。由于帧是以数组的形式表示的，因此只需要减去随后两个帧的数组，就能得到像素差值，静态帧的像素差值应该较低，而一旦图像中出现较大的运动，像素差值就会变高。</li>
<li><strong>使用光流检测运动</strong>：通过光流，可以了解视频帧上的单个像素是如何移动的。
<ul>
<li><strong>密集光流</strong> 计算矢量场，显式每个像素的移动位置。</li>
<li><strong>稀疏光流</strong>  基于提取图像中的一些显著特征，并建立其从一帧到另一帧的轨迹。</li>
</ul>
</li>
</ul>
<br/>
<hr>
<br/>
<h1 id="卷积神经网络">卷积神经网络</h1>
<p>我们希望能够识别图片上的物体，而不管图片中的确切位置。计算机视觉不同于一般的分类，因为当我们试图在图片中找到某个物体时，我们是在扫描图片，寻找一些特定的模式以及其组合。</p>
<p>为了提取模式，我们将使用卷积滤波器的概念。图像是由二位矩阵或具有颜色深度的三维张量表示的。应用滤波器意味着，我们需要一个相对较小的过滤器卷积核矩阵，对于原始图像中的每个像素，我们都要计算其与邻近点的加权平均值。我们可以将其视为在整个图像上滑动的一个小窗口，并根据滤波器卷积核矩阵中的权重对所有像素进行平均。</p>
<br/>
<br/>
<h2 id="卷积神经网络背后的主要理念">卷积神经网络背后的主要理念</h2>
<p>CNN 的工作方式基于以下重要理念：</p>
<ul>
<li>卷积滤波器可提取模式</li>
<li>我们可以在设计网络时自动训练滤波器</li>
<li>我们可以使用同样的方法来发现高级特征中的模式，而不仅仅是原始图像中的模式。因此，CNN 的特征提取工作是基于特征的层次结构，从低层次的像素组合开始，一直到更高层的图片部分组合。</li>
</ul>
<br/>
<br/>
<h2 id="金字塔架构">金字塔架构</h2>
<p>大多数用于图像处理的卷积神经网络都采用所谓的金字塔架构。应用于原始图像的第一个卷积层通常具有相对较少的滤波器，这些滤波器对应不同的像素组合（如水平/垂直的笔画线条）。在下一层中，我们会减少网络的空间维度，增加滤波器的数量，从而对应更多可能的简单特征组合。每过一层，随着我们向最终分类器的迈进，图像的空间维度就会降低，滤波器的数量就会增加。</p>
<br/>
<hr>
<br/>
<h1 id="著名的卷积网络神经架构">著名的卷积网络神经架构</h1>
<br/>
<br/>
<h2 id="vgg-16架构">VGG-16架构</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/vgg-16-arch.jpg"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/vgg-16-arch.jpg, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/vgg-16-arch.jpg 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/vgg-16-arch.jpg 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/vgg-16-arch.jpg"
        title="VGG-16" /></p>
<br/>
<br/>
<h2 id="resnet架构">ResNet架构</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/resnet-block.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/resnet-block.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/resnet-block.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/resnet-block.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/resnet-block.png"
        title="ResNet" /></p>
<br/>
<br/>
<h2 id="inception架构">Inception架构</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/inception.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/inception.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/inception.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/inception.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/inception.png"
        title="Inception" /></p>
<br/>
<br/>
<h2 id="mobilenet">MobileNet</h2>
<br/>
<hr>
<br/>
<h1 id="预训练网络和迁移学习">预训练网络和迁移学习</h1>
<p>卷积神经网络的训练需要花费大量的时间和数据。然而，大部分时间都花在学习网络可以用来从图像提取模式的最佳底层滤波器上。</p>
<p>一个自然而然的问题出现了——能否使用在一个数据集上训练好的神经网络，在不需要完整的训练过程的情况下，将其用于不同图像的分类？</p>
<p>这种方法被称为迁移学习，因为我们将一些知识从一个神经网络模型迁移到另一个模型。在迁移学习中，我们通常从一个预先训练好的模型开始，该模型已经在一些大型图像数据集上训练过。这些模型已经可以很好地从普通图像中提取不同的特征，在很多情况下，只需在这些提取的特征之上构建分类器就能获得很好的结果。</p>
<br/>
<br/>
<h2 id="作为特征提取器的预训练模型">作为特征提取器的预训练模型</h2>
<p>如果我们再足够大的通用和多样化图像数据集上对卷积神经网络进行训练，该网络就能学会提取这些共同特征。</p>
<p>最常用的 CNN 架构在上一节中已经描述。</p>
<br/>
<br/>
<h2 id="练习-迁移学习">练习-迁移学习</h2>
<p><a href="https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/4-ComputerVision/08-TransferLearning/TransferLearningTF.ipynb" target="_blank" rel="noopener noreffer ">Transfer Learning - TensorFlow</a></p>
<br/>
<br/>
<h2 id="可视化对抗猫">可视化对抗猫</h2>
<p>预训练神经网络的大脑中包含不同的模式，包括理想猫（理想狗等）的概念。以某种方式将这一图像可视化会很有趣。然而，这并不简单，因为模式遍布整个网络权重，而且以层次结构组织。</p>
<p>我们可以采取的一种方法是从随机图像开始，然后尝试使用梯度下降优化技术来调整图像，是网络开始认为这是一只猫。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ideal-cat-loop.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ideal-cat-loop.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ideal-cat-loop.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ideal-cat-loop.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ideal-cat-loop.png"
        title="理想猫循环" /></p>
<br/>
<p>但是，如果我们这样做，就会得到与随机噪声非常相似的结果。这是因为有很多方法可以让网络认为输入图像是一只猫，包括一些视觉上毫无意义的方法。虽然这些图像包含了很多猫的典型模式，但没有任何东西能限制它们在视觉上与众不同。</p>
<p>为了改善结果，我们可以在损失函数中加入“变异损失”——这是一个显示图像相邻像素相似程度的指标。将变异损失最小化可以使图像更平滑，并消除噪音，从而显示出更具视觉吸引力的图像。</p>
<p>下面是一个理想图像的例子，这些图像被高概率归类为猫和斑马：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ideal-images.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ideal-images.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ideal-images.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ideal-images.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ideal-images.png"
        title="理想图像" /></p>
<br/>
<p>类似的方法也可用于对神经网络所谓的对抗性攻击。假设我们想愚弄神经网络，让狗看起来像猫。如果我们使用狗的图像，而网络将其识别为狗，那么我们可以使用梯度下降优化法对其稍作调整，知道网络开始将其分类为猫。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/original-adversaria-dog.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/original-adversaria-dog.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/original-adversaria-dog.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/original-adversaria-dog.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/original-adversaria-dog.png"
        title="对抗攻击" /></p>
<br/>
<hr>
<br/>
<h1 id="深度学习训练技巧">深度学习训练技巧</h1>
<p>随着神经网络越来越深入，其训练过程也变得越来越具有挑战性。其中一个主要问题是所谓的 <strong>梯度消失</strong> 或 <strong>梯度爆炸</strong>。</p>
<br/>
<br/>
<h2 id="将数值保持在合理区间">将数值保持在合理区间</h2>
<p>为了使数值计算更加稳定，我们希望确保神经网络中的所有数值都在合理的范围内。这并不是一个非常严格的要求，但浮点运算的性质决定了不同量级的数值无法精确地放在一起处理。</p>
<p>大多数激活函数在 <code>[-1..1]</code> 附近具有非线性，因此将所有输入数据缩放至 <code>[-1..1]</code> 或 <code>[0..1]</code> 区间是合理的。</p>
<br/>
<br/>
<h2 id="初始权重初始化">初始权重初始化</h2>
<p>在理想情况下，我们希望数值在经过网络层后保持在同一范围内。因此，在初始化权重时，必须保持权重值的分布。</p>
<p>正态分布 <code>N(0,1)</code> 并不是一个好主意，如果我们有 n 个输入，输出的标准偏差就是 n，而且数值和可能跳出 <code>[0..1]</code> 区间。</p>
<p>经常使用的初始化如下：</p>
<ul>
<li>均匀分布</li>
<li><code>N(0,1/n)</code></li>
<li><code>N(0,1/√n_in)</code></li>
<li><code>N(0,√2/(n_in+n_out))</code></li>
</ul>
<br/>
<br/>
<h2 id="批量归一化">批量归一化</h2>
<p>即使进行了适当的权重初始化，权重也可能在训练过程中任意变大或变小，从而使信号超出了适当的范围。可以使用归一化技术使信号恢复正常。</p>
<p>虽然有多种归一化技术（权重归一化、层归一化），但最常用的还是批量归一化。</p>
<p>批量归一化的原理是考虑整个小批量中的所有值，并根据这些值进行归一化（即减去平均值并除以标准偏差）。它是作为一个网络层来实现的，在应用权重之后、激活函数之前进行归一化。因此，可能会有更高的最终准确率和更快的训练速度。</p>
<br/>
<br/>
<h2 id="dropout">Dropout</h2>
<p>Dropout 技术能在训练过程中移除一定比例的随机神经元。</p>
<p>这种效应有几种解释：</p>
<ul>
<li>它可以被视为模型的随机冲击因子，使优化过程摆脱局部最小值的限制。</li>
<li>这可以看作是隐式模型平均。</li>
</ul>
<br/>
<br/>
<h2 id="防止过度拟合">防止过度拟合</h2>
<p>深度学习的一个非常重要的方面就是能够防止过度拟合。我们始终应该平衡模型参数数量与训练样本数量之间的关系。</p>
<p>有几种方法可以防止过度拟合：</p>
<ul>
<li>早期停止&ndash;持续监控验证集上的误差，并在验证误差开始增加时停止训练。</li>
<li>显式权重衰减/正则化&ndash;为权重绝对值较高的损失函数增加额外的惩罚，从而防止模型得到非常不稳定的结果。</li>
<li>模型平均&ndash;训练多个模型，然后求平均值。这有助于将方差最小化。</li>
<li>Dropout（隐式模型平均）</li>
</ul>
<br/>
<br/>
<h2 id="优化器和训练算法">优化器和训练算法</h2>
<p>训练的另一个重要方面是选择好的训练算法。虽然经典的梯度下降是一种合理的选择，但有时会过于缓慢，或导致其他问题。</p>
<p>在深度学习中，我们使用随机梯度下降法，它从训练集中随机选取小批量数据进行梯度下降。</p>
<ul>
<li>动量随机梯度下降法</li>
<li>Adagrad, Adam</li>
<li>梯度剪裁</li>
<li>学习率衰减</li>
</ul>
<br/>
<br/>
<h2 id="不同的网络架构">不同的网络架构</h2>
<p>为你的问题选择正确的、已被证明适用于特定任务的网络架构。</p>
<br/>
<hr>
<br/>
<h1 id="自动编码器">自动编码器</h1>
<p>在训练神经网络时，一个问题是我们需要大量标记数据。就图像分类而言，我们需要将图像分成不同的类别，这需要人工操作。</p>
<p>不过，我们可能希望使用原始数据来训练卷积神经网络特征提取器，这就是所谓的自监督学习。我们将使用训练图像作为网络输入输出，而不是标签。自动编码器的主要思想，将有一个编码器网络，将输入图像转换到某个潜在空间，然后是解码器网络，其目标是重建原始图像。</p>
<p>自动编码器是一种人工神经网络，用于学习未标记数据的有效编码。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/autoencoder_schema.jpg"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/autoencoder_schema.jpg, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/autoencoder_schema.jpg 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/autoencoder_schema.jpg 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/autoencoder_schema.jpg"
        title="自动编码器" /></p>
<br/>
<br/>
<h2 id="自动编码器的使用场景">自动编码器的使用场景</h2>
<p>虽然重建原始图像本身似乎没什么用，但在一些情况下，自动编码器却特别有用：</p>
<ul>
<li>降低图像维度，实现可视化或训练图像嵌入。</li>
<li>去噪</li>
<li>超分辨率</li>
<li>生成模型</li>
</ul>
<br/>
<br/>
<h2 id="变异自动编码器">变异自动编码器</h2>
<p>传统的自动编码器以某种方式降低输入数据的维度，找出输入图像的重要特征。然而，潜向量往往没有太大意义。</p>
<p>要训练生成式模型，最好对潜空间有一定的了解。这一想法让我们想到了变异自动编码器，用于预测潜在参数的统计分布，即所谓的潜分布。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/vae.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/vae.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/vae.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/vae.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/vae.png"
        title="VAE" /></p>
<br/>
<p>变异自动编码器使用由两部分组成的复杂损失函数：</p>
<ul>
<li>重建损失，是显示重建图像与目标图像接近的损失函数。</li>
<li>KL 损失，确保潜变量分布接近正态分布。</li>
</ul>
<p>VAE 的一种重要优势是，它能让我们相对轻松地生成新图像，因为我们知道从哪个分布中对潜向量进行采样。</p>
<br/>
<br/>
<h2 id="自动编码器的特性">自动编码器的特性</h2>
<ul>
<li>数据专用性，它们只适用于经过训练的图像类型。</li>
<li>有损耗，重建后的图像与原始图像不同。</li>
<li>适用于未标记的数据</li>
</ul>
<br/>
<hr>
<br/>
<h1 id="生成式对抗网络">生成式对抗网络</h1>
<p>前面，我们了解了生成式模型——可以生成与训练数据集中相似的图像。VAE 就是生成式模型的一个很好的例子。</p>
<p>但是，如果我们尝试用 VAE 生成真正有意义的东西，比如一幅分辨率合理的画作，就会发现训练收敛效果并不好。针对这种用例，我们应该了解另一种专门针对生成模型的架构，生成式对抗网络。</p>
<p>GAN 的主要理念是让两个神经网络相互训练：</p>
<ul>
<li>生成器是一个网络，它获取一些随机矢量，然后生成图像。</li>
<li>判别器是一个获取图像的网络，它可以判别图像是真实的（来做训练数据集），还是有生成器生成的。它本质上是一个图像分类器。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/gan_architecture.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/gan_architecture.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/gan_architecture.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/gan_architecture.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/gan_architecture.png"
        title="GAN" /></p>
<br/>
<br/>
<h2 id="判别器">判别器</h2>
<p>判别器的结构与普通图像分类网络并无不同。在最简单的情况下，它可以是全连接分类器，但最有可能是卷积网络。</p>
<p>卷积神经网络判别器由以下几层组成：若干的卷积 + 汇集（空间大小依次递减）和一个/多个全连接层，以获得特征向量和最终二元分类器。</p>
<br/>
<br/>
<h2 id="生成器">生成器</h2>
<p>生成器稍微复杂一些。可将其视为反向判别器。从潜向量开始，它有一个全连接层，将其转换为所需的大小/形状，然后进行解旋和升旋。这与自动编码器的解码器部分类似。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/gan_arch_detail.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/gan_arch_detail.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/gan_arch_detail.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/gan_arch_detail.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/gan_arch_detail.png"
        title="生成器" /></p>
<br/>
<br/>
<h2 id="训练生成式对抗网络">训练生成式对抗网络</h2>
<p>GAN 之所以被称为对抗型网络，是因为生成器与判别器之间存在着持续的竞争。在这种竞争过程中，生成器和判别器都会不断改进，从而使网络学会生成越来越好的图像。</p>
<p>训练分两个阶段进行：</p>
<ul>
<li>训练判别器。这项任务很简单：用生成器生成一批图像（标记为 0，代表假图像）。然后从输入数据集中提取一批图像（标记为 1， 代表真图像）。我们会得到一些判别损失，然后进行反推。</li>
<li>训练生成器。这一点有些棘手，因为我们无法直接知道生成器的预期输出。我们使用由生成器和判别器组成的整个 GAN 网络，向其输入一些随机矢量，并预期结果为 1（对应真是图像）。然后，我们冻结判别器的参数（我们不希望在这一步对其进行训练），并执行反向推演。</li>
</ul>
<p>在这一过程中，生成器和判别器的损耗都不会明显降低。在理想情况下，它们应该会出现振荡，这与两个网络的性能都有所提高是相对应的。</p>
<br/>
<br/>
<h2 id="生成式对抗网络训练的问题">生成式对抗网络训练的问题</h2>
<p>GAN 特别难以训练，下面是几个问题：</p>
<ul>
<li>模式崩溃。指生成器学会生成一个成功的图像来欺骗生成器，而不是生成各种不同的图像。</li>
<li>对超参数的敏感性。GAN 根本不会收敛，然后学习率会突然下降，从而导致收敛。</li>
<li>保持生成器和判别器之间的平衡。在很多情况下，判别器的损失会相对较快地降到零，从而导致生成器无法继续训练。为了解决这个问题，可以尝试为生成器和判别器设置不同的学习率，或在损失已经过低的情况下跳过判别器训练。</li>
<li>高分辨率训练。由于重建卷积网络的层数过多而导致伪影。此问题通常用渐进式增长来解决，即首先在低分辨率图像上训练几层，然后解锁或增加几层。</li>
</ul>
<br/>
<br/>
<h2 id="风格转换">风格转换</h2>
<p>GAN 是生成艺术图像的绝佳方法。另一种有趣的技术是所谓的风格转换。它采用一种内容图像，并应用风格网络中的过滤器，以不同的风格重新绘制。</p>
<p>其工作原理如下：</p>
<ul>
<li>从随机噪声图像开始</li>
<li>目标是创建这样一种图像，它即接近内容图像，又接近风格图像。这将由两个损失函数决定：
<ul>
<li>内容损失，根据 CNN 从当前图像和内容图像的某些层提取的特征计算出来的。</li>
<li>风格损失，通过一种巧妙的方法，即使用革兰氏矩阵在当前图像和风格图像之间计算出来的。</li>
</ul>
</li>
<li>为了使图像更平滑并消除噪音，还引入了变异损失，它可以计算相邻像素之间的平均距离。</li>
<li>主要的优化环路使用了梯度下降算法调整当前图像，以尽量减少总损失（所有三项损失的加权和）。</li>
</ul>
<br/>
<hr>
<br/>
<h1 id="物体检测">物体检测</h1>
<p>迄今为止，我们所处理的图像分类模型都是通过图像得出分类结果。然而，在很多情况下，我们并不希望仅仅知道图片上有物体，还希望能够确定物体的精确位置。这正是物体检测的意义所在。</p>
<br/>
<br/>
<h2 id="物体检测的原生方法">物体检测的原生方法</h2>
<p>假设我们想在一张图片上找到一只猫，那么非常简单的物体检测方法如下：</p>
<ul>
<li>将图片分解成若干块瓷砖。</li>
<li>对每块瓷砖进行图像分类。</li>
<li>激活度足够高的瓷砖可被视为包含相关物体。</li>
</ul>
<p>然而，这种方法远非理想，因为它只能让算法非常不精确地确定物体的边界框。要想获得更精确的定位，需要进行某种回归来预测边界框的坐标——为此，需要特定的数据集。</p>
<br/>
<br/>
<h2 id="物体检测回归">物体检测回归</h2>
<br/>
<br/>
<h2 id="物体检测数据集">物体检测数据集</h2>
<br/>
<br/>
<h2 id="物体检测指标">物体检测指标</h2>
<p>对于物体检测，我们即需要衡量分类的正确性，也需要衡量推断边界框位置的准确性。对此，使用交并比（IoU, Intersection over Union）来衡量边框的重叠程度。</p>
<p>概念很简单，用两个图形的交集面积除以它们的结合面积。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/iou_equation.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/iou_equation.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/iou_equation.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/iou_equation.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/iou_equation.png"
        title="IoU" /></p>
<br/>
<p>平均精度（Average Precision）</p>
<br/>
<p>平均精度均值(mAP, Mean Average Precison)</p>
<br/>
<br/>
<h2 id="不同的物体检测方法">不同的物体检测方法</h2>
<p>物体检测算法有两大类：</p>
<ul>
<li>区域建议网络（R-CNN, Fast R-CNN, Faster R-CNN）。主要思路是生成兴趣区域，然后着这些区域上运行 CNN，寻找最大激活度。这种方法一个缺点是速度较慢，因为需要对图像进行多次 CNN 分类。</li>
<li>单通道（YOLO, SSD, RetinaNet）方法。着这些架构中，设计的网络可以一次性预测类别和兴趣区域。</li>
</ul>
<br/>
<hr>
<br/>
<h1 id="分割算法">分割算法</h1>
<p>物体检测，让我们通过预测图像中物体的边界框来定位物体。然而，在某些任务中，不仅需要边界框，还需要更精确的物体定位。这项任务被称为分割（Segmentation）。</p>
<p>分割可以看作是像素分类，而对于图像中的每个像素，都必须预测其类别。主要有两种分割算法：</p>
<ul>
<li>语义分割（Semantic segmentation）。只能显示像素的类别，并不能区分同一列类别中的不同对象。</li>
<li>实例分割（Instance segmentation）。将类别划分为不同的实例。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/instance_vs_semantic.jpeg"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/instance_vs_semantic.jpeg, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/instance_vs_semantic.jpeg 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/instance_vs_semantic.jpeg 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/instance_vs_semantic.jpeg"
        title="语义分割和实例分割" /></p>
<br/>
<p>用于分割的神经架构各有不同，但都具有相同的结构。在某种程度上，它类似于自动编码器，但我们的目标不是解构原始图像，而是解析遮罩。因此，分割网络有以下几个部分：</p>
<ul>
<li>编码器从输入图像中提取特征。</li>
<li>解码器将这些特征转换为掩码图像（mask image），其大小和通道数与类别数相同。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/segm.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/segm.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/segm.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/segm.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/segm.png"
        title="分割" /></p>
<br/>
<br/>
<h2 id="医学影像分割">医学影像分割</h2>
<br/>
<hr>
<br/>
<h1 id="自然语言处理">自然语言处理</h1>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-nlp.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-nlp.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-nlp.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-nlp.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/ai-nlp.png"
        title="自然语言处理" /></p>
<br/>
<p>讨论使用神经网络处理与自然语言处理（NLP, Natural Language Processing）相关的任务。我们希望计算机能够解决许多 NLP 问题：</p>
<ul>
<li><strong>文本分类</strong>（Text Classification）是与文本序列相关的典型分类问题。如将文章分类为体育、经济和政治等类别。</li>
<li><strong>情感分析</strong>（Sentiment analysis）是一个典型的回归问题。根据句子含义的正负面程度，赋予一个相应的情感数字。如“在这家餐厅，我喜欢这里的菜肴，但气氛很糟糕”。</li>
<li><strong>命名实体识别</strong>（NER, Named Entity Recognition）指从文本中提取特定实体的问题。如“我明天需要飞往巴黎”这句话，明天指日期，巴黎指地点。</li>
<li><strong>关键字提取</strong>（Keyword extraction）与 NER 类似，但我们需要自动提取对句子意义重要的词语，而无需针对特定实体进行预训练。</li>
<li><strong>文本聚类</strong>（Text clustering），当我们想将类似的句子归类在一起时，文本聚类就会派上用场。</li>
<li><strong>问题解答</strong>（QA, Question Answering）指模型回答特定问题的能力。</li>
<li><strong>文本生成</strong>（Text Generation）指模型生成新文本的能力。先进的文本生成模型（如 GPT-3），能够使用一种称为<a href="https://towardsdatascience.com/software-3-0-how-prompting-will-change-the-rules-of-the-game-a982fbfe1e0" target="_blank" rel="noopener noreffer ">提示编程</a>（prompt programming）或<a href="https://medium.com/swlh/openai-gpt-3-and-prompt-engineering-dcdc2c5fcd29" target="_blank" rel="noopener noreffer ">提示工程</a>（prompt engineering）的技术解决其他 NLP 任务。</li>
<li><strong>文本摘要</strong>（Text summarization）是一种概括长篇文字的技术。</li>
<li><strong>机器翻译</strong>（Machine translation）可视为一种语言文本理解和另一种语言文本生成的结合。</li>
</ul>
<br/>
<p>最初，大多数 NLP 任务都是使用语法等传统方法解决的。如今，使用神经网络可以更有效地解决许多 NLP 任务。</p>
<p><a href="https://www.nltk.org/" target="_blank" rel="noopener noreffer ">自然语言处理工具包</a> 的 Python 库中实现了许多经典的 NLP 方法。</p>
<br/>
<hr>
<br/>
<h1 id="用张量表示文本">用张量表示文本</h1>
<br/>
<br/>
<h2 id="文本分类">文本分类</h2>
<p>讨论文本分类任务。</p>
<br/>
<br/>
<h2 id="表示文本">表示文本</h2>
<p>如果我们想用神经网络解决 NLP 任务，就需要某种方法将文本表示为张量。计算机能将文本字符表示为数字，并通过 ASCII 或 UTF-8 等编码方式来表示。</p>
<p>作为人类，我们了解每个字母代表什么，以及所有字符如何组成一个句子。然而，计算机本身并不具备这种理解能力，神经网络必须在训练过程中学习其含义。</p>
<p>因此，在表示文本时，我们可以使用不同的方法：</p>
<ul>
<li><strong>字符级表示法</strong>，即将每个字符视为一个数字来表示文本。</li>
<li><strong>单词级表示法</strong>，创建一个包含文本中所有词（word）的词汇表（vocabulary），然后使用独热编码（one-hot encoding）来表示单词。此方法在某种程度上更好，因为每个字母本身并没有太多意义，因此通过更高层次的语义概念——词，简化了神经网络的任务。不过，由于字典容量较大，我们需要处理高纬稀疏张量。</li>
</ul>
<p>无论采用哪种表示法，首先需要将文本转换成一串词块（token），一个词元可以是一个字符、一个词，有时甚至是一个词的一部分。然后，将词元转换为一个数字，通常使用词汇表，这个数字可以通过独热编码输入到神经网络。</p>
<br/>
<br/>
<h2 id="n元组">N元组</h2>
<p>在自然语言中，词的确切含义只能根据上下文来确定。例如 neural network 与 fishing network 的含义就完全不同。考虑到这一点的方法之一是在词对（pairs of words）的基础上建立我们的模型，并将词对视为独立的词汇表词元。</p>
<p>&ldquo;I like to go fishing&rdquo; 这个句子就可以用下面的词块序列来表示：I like, like to, to go, go fishing。这种方法的问题在于，词典的容量会大幅增加，而像 go fishing 和 go shopping 这样的组合会由不同的词块来表示，尽管使用的是同一个动词，但它们在语义上没有任何相似之处。</p>
<p>在某些情况下，还可以考虑三元组（tri-grams）（三个词的组合）。因此，这种方法通常被称为 N元组（n-grams）。此外，使用字符级表示的 n-gram 也很有意义，在此情况下，n-gram 将大致对应于不同的音节。</p>
<br/>
<br/>
<h2 id="词袋">词袋</h2>
<p>在解决文本分类等内容时，需要用一个固定大小的向量来表示文本，并将其作为最终密集分类器的输入。要做到这一点，最简单的方法之一就是将所有单独的词表示组合起来，例如将它们相加。如果我们将每个词的单词编码相加，最终就会得到一个频率向量，显示每个词在文本中出现的次数，这种文本表示法称为 <strong>词袋</strong>（BoW, bag of words）。</p>
<p>从本质上将，词袋代表了文本中出现的词及其数量，这的确可以很好地说明文本的内容。例如，关于政治的新闻很可能包含国家、部门和领导人等信息。因此，<strong>词频</strong>（word frequency）在很多情况下可以很好地说明文本内容。</p>
<p>词袋的问题在于，某些常用词（如 and, is 等）会出现在大多数文本中，而且出现频率最高，从而掩盖了真正重要的词。可以通过考虑词在整个文档集中出现的频率来降低这些词的重要性。这就是 TF/IDF 方法背后的主要思想。</p>
<p>然而，这些方法都不能完全考虑文本的语义。需要更强大的神经网络模型来做到这一点。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bow.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bow.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bow.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bow.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bow.png"
        title="词袋" /></p>
<br/>
<hr>
<br/>
<h1 id="语义词嵌入">语义词嵌入</h1>
<p>Semantic word embeddings</p>
<p>在训练基于 BoW 或 TF/IDF 的分类器时，我们使用的是长度为 <code>vocab_size</code> 的高维词袋向量，并且我们明确地将低维位置表示向量转换为稀疏的独热（one-hot）表示。然而，这种独热表示并不节省内存。此外，每个词都是独立处理的，也就是说，独热编码向量并不能表达词之间的任何语义相似性（semantic similarity）。</p>
<p>嵌入（embedding）的概念是用低维密集向量（lower-dimensional dense vectors）来表示词，这种向量以某种方式反映词的语义。可将嵌入视为降低词向量维度的一种方法。</p>
<p>因此，嵌入层会将作为一个词作为输入，并产生一个指定 <code>embeeding_size</code> 的输出向量。从某种意义上说，它与 <code>Linear</code> 层非常相似，但它不接收独热编码向量，而是接收词编号作为输入，这样我们就可以避免创建大量的独热编码向量。</p>
<p>通过将嵌入层作为分类器网络的第一层，我们可以将词袋模型转换为嵌入袋模型，即首先将文本中的每个词转换为相应的嵌入，然后计算所有这些嵌入的聚合函数（如总和、平均值或最大值等）。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/embedding-classifier-example.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/embedding-classifier-example.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/embedding-classifier-example.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/embedding-classifier-example.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/embedding-classifier-example.png"
        title="嵌入分类器示例" /></p>
<br/>
<br/>
<h2 id="语义嵌入-word2vec">语义嵌入-Word2Vec</h2>
<p>Semantic Embeddings</p>
<p>虽然嵌入层学会了将词映射到向量表示中，但这种表示并不一定具有太多的语义。如果能学会一种向量表示法，使相似的词语或同义词对应于在某种向量距离上相互接近的向量，那就更好了。</p>
<p>为此，我们需要以特定的方式在大量文本集合上预先训练我们的嵌入模型。其中一种训练语义嵌入的方法称为 <strong>Word2Vec</strong>。它基于两种主要架构，用于生成词的分布式表示：</p>
<ul>
<li>连续词袋（CBoW, Continuous Bag-of-Words），着这种结构中，我们训练模型从周围上下文中预测一个词。</li>
<li>连续跳格（Continuous skip-gram），与 CBoW 相反。该模型使用周围的语境词窗口来预测当前单词。</li>
</ul>
<p>CBoW 的速度更快，而 skip-gram 的速度较慢，但在表示不常见的词方面做的更好。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/example-algorithms-for-converting-words-to-vectors.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/example-algorithms-for-converting-words-to-vectors.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/example-algorithms-for-converting-words-to-vectors.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/example-algorithms-for-converting-words-to-vectors.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/example-algorithms-for-converting-words-to-vectors.png"
        title="Word2Vec" /></p>
<br/>
<p>Word2Vec 预训练嵌入也可以用来代替神经网络中的嵌入层。不过，我们需要处理词汇问题，因为用于预训练 Word2Vec 的词汇很可能与我们文本语料库中的词汇不同。</p>
<br/>
<br/>
<h2 id="上下文嵌入">上下文嵌入</h2>
<p>Contextual Embeddings</p>
<p>传统预训练嵌入表示法（如 Word2Vec）的一个主要局限是词义消歧问题（word sense disambiguation）。虽然它可以捕捉到上下文中的部分词义，但一个词的所有可能含义都会被编码到相同的嵌入中。这可能会给下游模型带来问题，因为许多词在不同的语境中会有不同的含义。</p>
<p>为了克服这一局限，我们需要根据语言模型（language model）来构建嵌入，因为语言模型是在大量文本语料库中训练出来的，知道在不同语境中如何将单词组合在一起。</p>
<br/>
<hr>
<br/>
<h1 id="语言模型">语言模型</h1>
<p>Language Modeling. Training your own embeddings.</p>
<p>语义嵌入实际上是语言模型的第一步——创建能以某种方式理解语言性质的模型。</p>
<p>语言模型背后的主要理念是以无监督的方式在未标记的数据集上对其进行训练。这一点很重要，因为我们有大量的未标记文本，而标记文本的数量总是受限于我们在标记上所能花费的精力。大多数情况下，我们可以建立能够预测文本中缺失单词（predict missing words）的语言模型，因为在文本中随机屏蔽一个单词并将其作为训练样本是很容易的。</p>
<br/>
<br/>
<h2 id="训练嵌入">训练嵌入</h2>
<p>Training Embeddings</p>
<p>在前面的示例中，我们使用了预先训练好的语义嵌入，但如何训练这些嵌入也很有意思。有几种可能的思路可以使用：</p>
<ul>
<li>N-Gram 语言模型</li>
<li>CBoW</li>
<li>Skip-gram</li>
</ul>
<br/>
<hr>
<br/>
<h1 id="循环神经网络">循环神经网络</h1>
<p>Recurrent Neural Networks, RNN</p>
<p>在前面的章节中，我们使用了丰富的文本语义表示和嵌入式之上的简单线性分类器。这种架构的作用是捕捉句子中单词的综合含义，但它并不考虑单词的顺序，因为在嵌入式之上进行的聚合操作会从原始文本中删除这一信息，由于这些模型无法对单词顺序进行建模，因此无法解决更复杂或更模糊的任务，如文本生成或问题解答。</p>
<p>要捕捉文本序列的含义，我们需要使用另一种神经网络架构——循环神经网络（RNN）。在 RNN 中，我们每次将句子中的一个符号传递个网络，网络会产生一些状态，然后再将下一个符号传递个网络。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn.png"
        title="RNN" /></p>
<br/>
<br/>
<h2 id="rnn单元剖析">RNN单元剖析</h2>
<p>Anatomy of an RNN Cell</p>
<p>它接受前一个状态 $S_{i-1}$ 和当前符号 $X_i$ 作为输入，并必须产生输出状态 $S_i$。</p>
<p>一个简单的 RNN cell 内部有两个权重矩阵：一个是转换输入符号（称之为 W），另一个是转换输入状态（称之为 H）。在这种情况下，网络输出的计算公式为 $σ(W×X_i+H×S_{i-1}+b)$，其中 σ 是激活函数，b 是附加偏差。</p>
<p>在许多情况下，输入词块在进入 RNN 之前会经过嵌入层，以降低维度。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-anatomy.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-anatomy.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-anatomy.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-anatomy.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-anatomy.png"
        title="RNN剖析" /></p>
<br/>
<br/>
<h2 id="长短期记忆">长短期记忆</h2>
<p>Long Short Term Memory (LSTM)</p>
<p>经典 RNN 的主要问题之一是所谓的梯度消失问题（vanishing gradients）。由于 RNN 是通过一次反向传播进行端到端训练的，因此很难将误差传播到网络的第一层，网络也就无法学习远处词块之间的关系。避免此问题的方法之一是通过使用所谓的门（gates）来引入显式状态管理（explicit state management）。有两种著名的此类结构：长短期记忆（LSTM）和门控中继单元（GRU, Gated Relay Unit）。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/long-short-term-memory-cell.svg"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/long-short-term-memory-cell.svg, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/long-short-term-memory-cell.svg 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/long-short-term-memory-cell.svg 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/long-short-term-memory-cell.svg"
        title="LSTM" /></p>
<br/>
<p>LSTM 网络的组织方式与 RNN 类似，但在层与层之间传递的是两种状态：实际状态 C 和隐藏向量 H。在每个单元中，隐藏向量 H 与输入 $X_i$ 相连，它们通过门控制状态 C 的变化。每个门都是一个具有sigmoid 激活功能（输出范围为 <code>[0, 1]</code>）的神经网络，当它与状态向量相乘时，可以将其视为一个比特掩码。</p>
<p>有以下几个门（上图中从左到右依次为）：</p>
<ul>
<li>forget gate，获取一个隐藏向量，并确定我们需要遗忘向量 C 中的哪些分量，以及哪些需要传递。</li>
<li>input gate，从输入矢量和隐藏矢量中获取一些信息，并将其插入状态。</li>
<li>output gate</li>
</ul>
<p>状态 C 的组成部分可以看作是一些可以打开或关闭的标志。</p>
<br/>
<br/>
<h2 id="双向和多层rnn">双向和多层RNN</h2>
<br/>
<hr>
<br/>
<h1 id="生成式循环网络">生成式循环网络</h1>
<p>Generative Recurrent Networks</p>
<p>循环神经网络（RNN）及其门控单元变体（如 LSTM 和 GRU）为语言建模提供了一种机制，即它们可以学习单词排序，并为序列中下一个单词提供预测。这使得我们可以将 RNN 用于生成任务（generative task），如普通文本生成、机器翻译，甚至图像字幕。</p>
<p>每个 RNN 单元都会产生下一个隐藏状态作为输出。不过，我们也可以为每个递归单元添加另一个输出，这样就能输出一个序列（与原始序列等长）。此外，我们还可以使用每一步都不接受输入的 RNN 单元，只接受某个初始状态向量，然后产生一串输出。</p>
<p>如下图所示，不同的神经架构都可以实现：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/unreasonable-effectiveness-of-rnn.jpg"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/unreasonable-effectiveness-of-rnn.jpg, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/unreasonable-effectiveness-of-rnn.jpg 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/unreasonable-effectiveness-of-rnn.jpg 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/unreasonable-effectiveness-of-rnn.jpg"
        title="Unreasonable Effectiveness of Recurrent Neural Networks" /></p>
<br/>
<ul>
<li><strong>one-to-one</strong>，有一个输入和输出的传统神经网络。</li>
<li><strong>one-to-many</strong>，是一种生成式架构，它接受一个输入值，并生成一系列输出值。例如，如果我们想训练一个能生成图片文字说明的图片字幕（image caption ing）网络，可以将一张图片作为输入，通过 CNN 获取其隐藏状态，然后让递归链（recurrent chain）逐字生成字幕。</li>
<li><strong>many-to-one</strong>，对应于上一单元中描述的 RNN 架构，例如文本分类。</li>
<li><strong>many-to-many</strong>（sequence-to-sequence），对应的任务如机器翻译，我们让第一个 RNN 将输入序列中的所有信息收集到隐藏状态中，然后由另一个 RNN 链将该状态展开到输出序列中。</li>
</ul>
<br/>
<p>在本单元中，我们将学习帮助我们生成文本的简单生成式模型。为简单起见，我们将使用字符级词块化（character-level tokenization）。</p>
<p>我们将逐步训练 RNN 生成文本。在每一步中，我们将获取长度为 <code>nchars</code> （n 个字符）的字符序列，并要求网络为每个输入字符生成下一个输出字符：</p>
<br/>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-generate.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-generate.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-generate.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-generate.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-generate.png"
        title="RNN生成" /></p>
<br/>
<p>在生成文本时（推理过程中），我们从某个提示（prompt）开始，通过 RNN 单元生成中间状态，然后从这个状态开始生成。每次生成一个字符，然后将状态和生成的字符传递给另一个 RNN 单元，生成下一个字符，直到生成足够多的字符为止。</p>
<br/>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-generate-inf.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-generate-inf.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-generate-inf.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-generate-inf.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/rnn-generate-inf.png"
        title="RNN生成" /></p>
<br/>
<br/>
<h2 id="软文本生成和温度">软文本生成和温度</h2>
<p>Soft text generation and temperature</p>
<p>每个 RNN 单元的输出式字符的概率分布（probability distribution）。如果我们总是将概率醉倒的字符作为生成文本的下一个字符，那么文本往往会在相同的字符序列之间反复循环（cycled），就像下例一样：</p>
<br/>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-txt" data-lang="txt">today of the second the company and a second the company ...
</code></pre></td></tr></table>
</div>
</div><br/>
<p>但是，如果我们看一下下一个字符的概率分布，可能几个最高概率之间的差别并不大，比如一个字符的概率是 0.2，另一个是 0.19，等等。例如，在查找 <code>play</code> 的下一个字符时，既可以时空格，也可以是 <code>e</code>（player）。</p>
<p>由此我们可以得出结论：选择概率较高的字符并不总是公平的，因为选择第二高的字符仍有可能得到有意义的文本。</p>
<p>更明智的做法是从网络输出给出的概率分布中抽取字符。我们还可以使用一个参数——<strong>温度</strong>，它可以使概率分布更平缓，以防我们想增加随机性，或使概率分布更陡峭，以防我们想更多地选择概率最高的字符。</p>
<br/>
<hr>
<br/>
<h1 id="注意力机制和变换器模型">注意力机制和变换器模型</h1>
<p>Attention Mechanisms and Transformers</p>
<p>机器翻译（machine translation）是 NLP 领域最重要的问题之一，也是谷歌翻译等工具的基本任务。本节将重点讨论机器翻译，或者更广义地说，任何序列到序列的任务（sequence-to-sequence），也称为句子转换。</p>
<p>在 RNN 中，序列到序列由两个递归网络实现，其中一个网络（编码器）将输入序列折叠为隐藏状态，而另一个网络（解码器），则将此隐藏状态展开为翻译结果。这种方法存在一些问题：</p>
<ul>
<li>编码器网络的最终状态很难记住句子的开头，因此导致长句子的模型质量较差。</li>
<li>序列中的所有单词对结果的影像相同。但实际上，输入序列中的特定词语对序列输出的影响往往大于其他词语。</li>
</ul>
<p>注意力机制（Attention Mechanisms），提供了一种对每个输入向量对每个 RNN 输出预测的上下文影响加权的方法。此机制可以增强神经网络输入数据中某些部分的权重，同时减弱其他部分的权重。其实现方式是在输入 RNN 和输出 RNN 的中间状态之间创建捷径。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/encoder-decoder-attention.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/encoder-decoder-attention.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/encoder-decoder-attention.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/encoder-decoder-attention.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/encoder-decoder-attention.png"
        title="注意力机制" /></p>
<p>下面是一个矩阵示例：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bahdanau-fig3.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bahdanau-fig3.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bahdanau-fig3.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bahdanau-fig3.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bahdanau-fig3.png"
        title="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bahdanau-fig3.png" /></p>
<br/>
<p>注意力机制是当前或接近当前 NLP 技术水平的主要原因。然而，增加注意力会大大增加模型参数的数量，从而导致 RNN 的扩展问题。扩展 RNN 的一个关键限制因素是，模型的递归性质使得批量和并行化训练具有挑战性。在 RNN 中，序列中的每个元素都需要按顺序处理，这意味着它并不容易并行化。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/EncDecAttention.gif"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/EncDecAttention.gif, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/EncDecAttention.gif 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/EncDecAttention.gif 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/EncDecAttention.gif"
        title="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/EncDecAttention.gif" /></p>
<br/>
<p>注意力机制的采用与这一限制因素相结合，创造了我们今天所熟知和使用的最先进的变换器（transformer）模型，如 BERT（基于变换器的双向编码器表示技术） 到 GPT3（生成式预训练变换模型）。GPT3 基于谷歌开发的 Transformer 模型。</p>
<br/>
<br/>
<h2 id="变换器模型">变换器模型</h2>
<p>变换器背后的主要理念之一是避免 RNN 的顺序性，并创建一个在训练过程中可并行的模型。要做到这一点，需要落实两个理念：</p>
<ul>
<li>位置编码（positional encoding）</li>
<li>使用自我注意力机制（self-attention）来捕捉模式，而不是使用 RNN 或 CNN。</li>
</ul>
<br/>
<br/>
<h3 id="位置编码">位置编码</h3>
<p>位置编码的原理如下：</p>
<ul>
<li>在使用 RNN 时，词块的相对位置由步数表示，因此无需明确表示。</li>
<li>但是，一旦我们转而使用注意力，就需要知道词块在序列中的相对位置。</li>
<li>为了获得位置编码，我们用序列中的词块位置序列（即0、1&hellip;）来增强我们的词块序列。</li>
<li>然后，我们将词块位置与词块嵌入向量混合。要将位置转换为向量，有以下不同的方法：
<ul>
<li>可训练嵌入，类似于词块嵌入。我们在词块及其位置之上应用嵌入层，产生相同维度的嵌入向量，然后将其相加。</li>
<li>固定位置编码功能。</li>
</ul>
</li>
</ul>
<br/>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/pos-embedding.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/pos-embedding.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/pos-embedding.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/pos-embedding.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/pos-embedding.png"
        title="位置编码" /></p>
<br/>
<br/>
<h3 id="多头自我注意力">多头自我注意力</h3>
<p>Multi-Head Self-Attention</p>
<p>接下来，我们需要在序列中捕捉一些模式。为此，变换器使用了自我注意力机制（self-attention），即对输入和输出的相同序列进行注意。应用自我注意可以让我们考虑到句子中的上下文，并了解哪些词语是相互关联。</p>
<p>例如，它能让我们看到哪些词是通过核心关联词（如 it）来指代的，同时还能将上下文考虑在内：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/CoreferenceResolution.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/CoreferenceResolution.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/CoreferenceResolution.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/CoreferenceResolution.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/CoreferenceResolution.png"
        title="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/CoreferenceResolution.png" /></p>
<br/>
<p>在变换器中，我们使用多头注意力（Multi-Head Attention），以便让网络能够捕捉到几种不同类型的依赖关系。例如长期与短期的词语关系，共同参照与其他关系。</p>
<br/>
<br/>
<h3 id="编码器-解码器注意力">编码器-解码器注意力</h3>
<p>Encoder-Decoder Attention</p>
<p>在变换器中，有两处使用了注意力：</p>
<ul>
<li>利用自我注意力捕获输入文本中的模式。</li>
<li>执行序列转换，它是编码器和解码器之间的注意力层。</li>
</ul>
<p>下图解释了编码器-解码器注意力的作用。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/transformer-animated-explanation.gif"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/transformer-animated-explanation.gif, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/transformer-animated-explanation.gif 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/transformer-animated-explanation.gif 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/transformer-animated-explanation.gif"
        title="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/transformer-animated-explanation.gif" /></p>
<p>由于每个输入位置都是独立映射到每个输出位置的，因此变换器比 RNN 具有更好的并行性，从而可以建立更大、更有表现力的语言模型。每个注意力头可用于学习单词之间的不同关系，从而改进下游的自然语言处理任务。</p>
<br/>
<br/>
<h2 id="bert">BERT</h2>
<p>基于变换器的双向编码器表示技术（BERT, Bidirectional Encoder Representations from Transformers），是一个非常大的多层变换器网络，BERT-base 有 12 层，BERT-large 有 24 层。该模型是第一个预训练模型，它在一个大型文本数据语料库（WikiPedia + books）上进行无监督训练（预测句子中的隐藏词）。在预训练过程中，模型吸收了大量的语言理解能力，然后可以通过微调利用其他数据集。这一个过程被称为 <strong>迁移学习</strong>（transfer learning）。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/jalammarBERT-language-modeling-masked-lm.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/jalammarBERT-language-modeling-masked-lm.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/jalammarBERT-language-modeling-masked-lm.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/jalammarBERT-language-modeling-masked-lm.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/jalammarBERT-language-modeling-masked-lm.png"
        title="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/jalammarBERT-language-modeling-masked-lm.png" /></p>
<br/>
<hr>
<br/>
<h1 id="命名实体识别">命名实体识别</h1>
<p>NER, Named Entity Recognition</p>
<br/>
<p>到目前为止，我们主要专注于一种 NLP 任务——分类。不过，神经网络也可以完成其它 NLP 任务。其中一项任务是命名实体识别（NER），即识别文本中特定实体，如地名、人名、日期时间间隔和化学式等。</p>
<br/>
<br/>
<h2 id="ner使用示例">NER使用示例</h2>
<p>假设你想开发一个自然语言聊天机器人，智能聊天机器人的工作方式是通过对输入句子进行文本分类来了解用户的需求。这种分类的结果就是所谓的意图，它决定了聊天机器人应该做什么。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bot-ner.png"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bot-ner.png, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bot-ner.png 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bot-ner.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/bot-ner.png"
        title="NER" /></p>
<br/>
<p>不过，用户可以在短语中提供一些参数。例如，在询问天气时，用户可能会指定一个地点或日期。机器人应该能够理解这些实体，并在执行操作前填写相应的参数。这正是 NER 的作用。</p>
<br/>
<br/>
<h2 id="作为词块分类的ner">作为词块分类的NER</h2>
<p>NER as Token Classification</p>
<p>NER 模型本质上是词块分类模型（token classification），因为对于每个输入词块，都需要判断它是否属于某个实体，如果属于，又属于哪个实体类别。</p>
<p>请看下面论文的题目：</p>
<p>Tricuspid valve regurgitation and lithium carbonate toxicity in a newborn infant.</p>
<p>这里的实体是：</p>
<ul>
<li><code>Tricuspid valve regurgitation</code> 是一种疾病（DIS）</li>
<li><code>Lithium carbonate</code> 是一种化学物质（CHEM）</li>
<li><code>Toxicity</code> 是一种疾病（DIS）</li>
</ul>
<p>请注意，一个实体可以跨越多个词块。在本例中，我们需要区分两个连续的实体。因此，通常为每个实体使用两个类——一个类表示实体的第一个词块（通常使用 <code>B-</code> 前缀，表示开始）；另一个类表示实体的延续（<code>I-</code>前缀，表示内部词块）。我们还使用 <code>O</code> 作为一个类来表示所有其他词块。这种词块标记被称为 BIO 标记。</p>
<br/>
<p>标记后，我们的标题看起来像这样：</p>
<table>
<thead>
<tr>
<th>Token</th>
<th>Tag</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tricuspid</td>
<td>B-DIS</td>
</tr>
<tr>
<td>valve</td>
<td>I-DIS</td>
</tr>
<tr>
<td>regurgitation</td>
<td>I-DIS</td>
</tr>
<tr>
<td>and</td>
<td>O</td>
</tr>
<tr>
<td>lithium</td>
<td>B-CHEM</td>
</tr>
<tr>
<td>carbonate</td>
<td>I-CHEM</td>
</tr>
<tr>
<td>toxicity</td>
<td>B-DIS</td>
</tr>
<tr>
<td>in</td>
<td>O</td>
</tr>
<tr>
<td>a</td>
<td>O</td>
</tr>
<tr>
<td>newborn</td>
<td>O</td>
</tr>
<tr>
<td>infant</td>
<td>O</td>
</tr>
<tr>
<td>.</td>
<td>O</td>
</tr>
</tbody>
</table>
<br/>
<p>由于我们需要在词块和类别之间建立一一对应的关系，因此我们可以根据这行图片训练一个最右边多对多神经网络模型：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/unreasonable-effectiveness-of-rnn.jpg"
        data-srcset="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/unreasonable-effectiveness-of-rnn.jpg, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/unreasonable-effectiveness-of-rnn.jpg 1.5x, https://raw.githubusercontent.com/zhang21/images/master/cs/ai/unreasonable-effectiveness-of-rnn.jpg 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/unreasonable-effectiveness-of-rnn.jpg"
        title="https://raw.githubusercontent.com/zhang21/images/master/cs/ai/unreasonable-effectiveness-of-rnn.jpg" /></p>
<br/>
<br/>
<h2 id="训练ner模型">训练NER模型</h2>
<p>由于 NER 模型本质上是一个词块分类模型，因此我们可以使用 RNN 来完成这项任务。在这种情况下，每个递归网络块都将返回词块 ID。</p>
<br/>
<hr>
<br/>
<h1 id="大语言模型和提示工程">大语言模型和提示工程</h1>
<p>Large Language Models, Prompt Programming and Few-Shot Tasks</p>
<p>在我们之前的所有任务中，我们都是使用已标记的数据集训练神经网络来执行特定任务。在 BERT 等大型转换器模型中，我们以自我监督的方式使用语言模型来构建语言模型，然后通过进一步的特定领域训练将其专门用于特定的下游任务。不过，事实证明，大型语言模型也可以在没有特定领域训练的情况下解决许多任务。</p>
<p>能够做到这一点的模型系列被称为 GPT（Generative Pre-Trained Transformer，生成式预训练转换器）。</p>
<br/>
<br/>
<h2 id="文本生成与困惑度">文本生成与困惑度</h2>
<p>《Language Models are Unsupervised Multitask Learners》论文中提出，神经网络无需下游训练即可完成一般任务。其主要思想是，许多其他任务都可以通过文本生成来建模，因为理解文本本质上就意味着能够生成文本。由于模型是在包含人类知识的大量文本中训练出来的，因此它会对各种主题有所了解。</p>
<br/>
<br/>
<h2 id="gpt是一个大家族">GPT是一个大家族</h2>
<p>GPT 不是一个单一的模型，而是由 OpenAI 开发和训练的一系列模型的集合。</p>
<table>
<thead>
<tr>
<th>GPT-2</th>
<th>GPT-3</th>
<th>GPT-4</th>
</tr>
</thead>
<tbody>
<tr>
<td>语言模型参数多达 15 亿</td>
<td>语言模型参数多大 1750 亿</td>
<td>100 兆参数，接受图像和文本输入，并输入文本</td>
</tr>
</tbody>
</table>
<br/>
<br/>
<h2 id="提示工程">提示工程</h2>
<p>Prompt Engineering</p>
<p>由于 GPT 经过大量数据的训练，能够理解语言和代码，因此它们会根据输入（提示）提供输出。提示是 GPT 的输入或查询，通过输入或查询，人们可以向模型提供下一步完成任务的指令。要获得理想的结果，你需要最有效的提示，这涉及到正确的单词、格式、短语甚至是符号。这种方法就是提示工程。</p>
<br/>
<hr>
<br/>
<h1 id="其他ai技术">其他AI技术</h1>
<p>包括：</p>
<ul>
<li>遗传算法（Genetic Algorithms）</li>
<li>深度强化学习（Deep Reinforcement Learning）</li>
<li>多代理系统（Multi-Agent Systems）</li>
</ul></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2024-03-31</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/ai-for-beginners/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://zhang21.cn/ai-for-beginners/" data-title="人工智能" data-hashtags="AI,人工智能"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://zhang21.cn/ai-for-beginners/" data-title="人工智能"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Reddit" data-sharer="reddit" data-url="https://zhang21.cn/ai-for-beginners/"><i class="fab fa-reddit fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://zhang21.cn/ai-for-beginners/" data-title="人工智能"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://zhang21.cn/ai-for-beginners/" data-title="人工智能"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/ai/">ai</a>,&nbsp;<a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/postgresql/" class="prev" rel="prev" title="PostgreSQL"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>PostgreSQL</a>
            <a href="/generative-ai/" class="next" rel="next" title="生成式人工智能">生成式人工智能<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="disqus_thread" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.83.1">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2017 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://zhang21.cn" target="_blank">Zhang21</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/css/lightgallery-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"><script type="text/javascript" src="https://zhang21.disqus.com/embed.js" defer></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/twemoji@14.0.2/dist/twemoji.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/thumbnail/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/zoom/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":20},"comment":{},"lightgallery":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"RZ22ZCTIDN","algoliaIndex":"hugo-index","algoliaSearchKey":"11ec277ef4d730e232eda9651548da78","highlightTag":"em","maxResultLength":20,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"twemoji":true};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
