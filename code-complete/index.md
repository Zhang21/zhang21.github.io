# 代码大全


代码大全2 一书笔记。

<!--more-->

<br/>

参考：

- 代码大全2

<br/>

---

<br/>

# 软件构建

开发软件过程：

- 定义问题
- 需求分析
- 规划构建
- 软件架构（高层设计）
- 详细设计
- 编码与调试
- 单元测试
- 集成测试
- 集成
- 系统测试
- 保障维护

<br/>

构建有时也被认为是编程。构建活动中的具体任务：

- 验证有关的基础工作已经完成。
- 确定如何测试所写的代码。
- 设计并编写类和子程序。
- 创建并命名变量和常量。
- 选择控制结构，组织语句块。
- 代码测试。
- 代码评审。
- 润饰代码。
- 将单独开发的多个软件集成为一体。
- 调整代码，让它更快更省。

<br/>

---

<br/>

# 理解软件开发

<br/>

---

<br/>

# 前期准备

<br/>

---

<br/>

# 构建决策

<br/>
<br/>

## 选择编程语言

<br/>
<br/>

## 编程约定

在构建开始之前，讲清除使用的编程约定。

<br/>

---

<br/>

# 软件构建中的设计

“软件设计” 意味着去构思、创造或发明一套方案，把一份计算机软件的规格说明书转变为可实际运行的软件。

设计不是在谁的头脑里直接跳出来的。它是在不断的设计评估、非正式讨论、编写和完善代码中演化而来。

软件的首要技术使命：管理复杂度。

没有谁的大脑容得下一个现代计算机程序。作为软件开发人员，不应该试着在同一时间把整个程序都塞进自己的大脑，而应该试着以某种方式去组织程序，以便能够在一个时刻可以专注于一个特定的部分。

在软件架构的层次上，可通过把整个系统分解为多个子系统来降低问题的复杂度。人类更容易理解多项简单的信息，而不是一项复杂的信息。所有软件的设计技术的目标都是把复杂问题分解成简单的部分。

保持子程序的短小精悍也能帮你减少思考的负担。

受着人类固有限制影响的程序员的底线，就是要写出既让自己容易理解，也能让别人容易看懂，而且很少错误的程序代码。

<br/>

高质量设计的特征：

- 最小复杂度
- 易于维护
- 松散耦合
- 可扩展性
- 可重用性
- 高扇入
- 低扇出
- 可移植性
- 精简性
- 层次性
- 标准技术

<br/>

设计的层次：

- 软件系统
- 分解为子系统和包
- 分解为包中的类
- 分解为类中的数据和子程序
- 子程序内部的设计

<br/>

常见设计模式

| 模式 | 描述 |
| - | - |
| Abstract Factory | 通过指定对象组的种类而非单个对象的类型来支持创建一组相关的对象 |
| Adapter | 把一个类的接口转变成为另一个接口 |
| Bridge | 把接口和实现分离开来，使它们可以独立地变化 |
| Composite | 创建一个包含其他同类对象的对象，使得客户代码可以与最上层对象交互而无须考虑所有的细节对象 |
| Decrorator | 给一个对象动态地添加职责，而无须为了每一种可能的职责配置情况去创建特定的子类（派生类） |
| Facade | 为没有提供一致接口的代码提供一个一致的接口 |
| Factory Method | 做特定基类的派生类的实例化时，除了在 Factory Method 内部之外均无须了解各派生对象的具体类型 |
| Iterator | 提供一个服务对象来顺序地访问一组元素中的各个元素 |
| Observer | 使一组相关对象相互同步，方法是让另一个对象负责：在这组对象中的任何一个发生改变时，由它把这种变化通知给这个组里的所有对象 |
| Singleton | 为有且仅有一个实例的类提供一种全局访问功能 |
| Strategy | 定义一组算法或行为，使得它们可以动态地相互替换 |
| Temple Method | 定义一个操作的算法结构，但是把部分实现的细节留给子类（派生类） |

<br/>

关于设计启发的总结：

- 寻找现实世界的对象
- 形成一致的抽象
- 封装实现细节
- 在可能的情况下继承
- 信息隐藏
- 找出容易改变的区域
- 保持松散耦合
- 探寻通用的设计模式
- 高内聚性
- 构造分层架构
- 严格描述类契约
- 分配职责
- 为测试而设计
- 避免失误
- 有意识地选择绑定时间
- 创建中央控制点
- 考虑使用蛮力
- 画一个图
- 保持设计模块化

<br/>

---

<br/>

# 可以工作的类

类是由一组数据和子程序构成的集合，也可以只是由一组子程序构成的集合。成为高效程序员的一个关键在于，当你开发任一部分的代码时，都能安全地忽视程序中尽可能多的其余部分。而类就是实现这一目标的首要工具。

<br/>
<br/>

## 抽象数据类型

类的基础：抽象数据类型（ADT, Abstract Data Type），是指一些数据以及对这些数据所进行的操作的集合。

要想理解面向对象编程，首先要理解 ADT。

抽象数据类型构成了类的基础。在支持类的编程语言里，可以把每个抽象数据类型用它自己的类实现。类还涉及继承和多态的概念。因此，考虑类的一种方式，就是把它看作使抽象数据类型再加上继承和多态两个概念。

<br/>
<br/>

## 良好的类接口

创建高质量的类，最重要就是创建一个好的接口（class interface）。

创建类的抽象接口的建议：

- 类的接口应该展现一致的抽象层次
- 一定要理解类所实现的抽象是什么
- 提供成对的服务
- 把不想关的信息转移到其他类中
- 尽可能让接口可编程，而不是表达语义
- 谨防在修改时破坏接口的抽象
- 不要添加与接口抽象不一致的公用成员
- 同时考虑抽象性和内聚性
- 尽可能地限制类和成员的可访问性
- 不要公开暴露成员数据
- 避免把私用的实现细节放入类的接口中
- 不要对类的使用者做出任何假设
- 避免使用友元类（friend class）
- 不要因为一个子程序里仅使用公用子程序，就把它归入公开接口
- 让阅读代码比编写代码更方便
- 要格外警惕从语义上破坏封装性
- 留意过于紧密的耦合关系
  - 尽可能地限制类和成员的可访问性
  - 避免友元类，因为它们之间是紧密耦合的。
  - 避免在类的公开接口中暴露成员数据
  - 要对从语义上破坏封装性保持警惕。

<br/>
<br/>

## 设计和实现的问题

类内部的设计和实现也同样重要。本节论述关于包含、继承、成员函数和数据成员、类之间的耦合性、构造函数、值对象与引用对象等问题。

<br/>
<br/>

### 包含

包含（containment），表示一个类含有一个基本数据元素或对象。

<br/>
<br/>

### 继承

继承（inheritance），一个类是另一个类的特化。

<br/>
<br/>

### 成员函数和数据成员

- 让类中子程序的数量尽可能少
- 禁止隐式地产生不需要的成员函数和运算符
- 减少类所调用的不同子程序的数量
- 对其它类的子程序的间接调用要尽可能少
- 一般来说，应尽量减少类和类之间相互合作的范围

<br/>
<br/>

### 构造函数

- 如果可能，应该在所有的构造函数中初始化所有的数据成员
- 用 private 构造函数来强制实现单件属性
- 优先采用深层复本，除非论证可行，才采用浅层复本

<br/>
<br/>

## 创建类的原因

- 为现实世界中的对象建模
- 为抽象的对象建模
- 降低复杂度
- 隔离复杂度
- 隐藏实现细节
- 限制变动的影响范围
- 隐藏全局数据
- 让参数传递更顺畅
- 建立中心控制点
- 让代码更易于重用
- 为程序族做规划
- 把相关操作包装到一起
- 实现某种特定的重构

<br/>
<br/>

### 应该避免的类

- 避免创建万能类（god class）
- 消除无关紧要的类
- 避免用动词命名的类

<br/>
<br/>

### 与具体编程语言相关的问题

不同语言之间跟类相关的差异：

- 在继承层次中被覆盖的构造函数和析构函数的行为
- 在异常处理时构造函数和析构函数的行为
- 默认构造函数的重要性
- 析构函数或终结器的调用时机
- 和覆盖语言内置的运算符相关的知识
- 当对象被创建和销毁时，或当其被声明时，或它所在的作用域退出时，处理内存的方式

<br/>
<br/>

## 包

包（package）

<br/>

---

<br/>

# 高质量的子程序

子程序（routines），是为了实现一个特定的目的而编写的一个可被调用的方法或过程。如 C++ 中的函数，Java 中的方法。

<br/>
<br/>

## 创建子程序的正当理由

- 降低复杂度
- 引入中间、易懂的抽象
- 避免代码重复
- 支持子类化
- 隐藏指针操作
- 提高可移植性
- 简化复杂的布尔判断
- 改善性能
- 确保所有的子程序都很小

<br/>
<br/>

## 在子程序层上设计

内聚性（cohesion），是指子程序中各种操作之间联系的紧密程度。

<br/>
<br/>

## 好的子程序名称

- 描述子程序所做的所有事情
- 避免使用无意义的、模糊或表述不清的动词
- 不要仅通过数字来形成不同的子程序名称
- 根据需要确定子程序名字的长度
- 给函数命名时要对返回值有所描述
- 给过程起名时使用预期强烈的动词加宾语的形式
- 准确使用对仗词（如 open/close）
- 为常用操作确立命名规则

<br/>
<br/>

## 子程序可以写多长

理论上认为的子程序最佳最大长度通常是一屏代码或打印出来一到两页的代码，也就是约 50-150 行代码。

超过 200 行代码的子程序，可能会增加出错率。

<br/>
<br/>

## 如何使用子程序参数

一些减少接口错误的指导：

- 按照输入-修改-输出的顺序排列参数
- 考虑自己创建 in 和 out 关键字
- 如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致
- 使用所有的参数
- 把状态或出错变量放在最后
- 不要把子程序的参数用作工作变量
- 在接口中对参数的假定加以说明
- 把子程序的参数个数限制在 7 个以内
- 考虑对参数采用某种表示输入、修改、输出的命名规则
- 为子程序传递用以维持其接口抽象的变量或对象
- 使用具名参数
- 确保实际参数与形式参数相匹配

<br/>
<br/>

## 使用函数时要考虑的问题

- 什么时候使用函数
- 什么时候使用过程
- 设置函数的返回值

<br/>
<br/>

## 宏子程序和内联子程序

- 把宏表达式整个包含在括号内
- 把含有多条语句的宏用大括号括起来
- 用给子程序命名的方法来给展开后代码形同子程序的宏命名，以便在需要时可以用子程序来替换宏

<br/>

---

<br/>

# 防御式编程

防御式编程的主要思想是，子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。更一般地说，其核心想法是要承认程序都会有问题，都需要被修改，聪明的程序员应该根据这一点来编程。

<br/>
<br/>

## 保护程序免遭非法输入数据的破坏

- 检查所有来源于外部的数据的值
- 检查子程序所有输入参数的值
- 决定如何处理错误的输入数据

<br/>
<br/>

## 断言

断言（assertion），是指在开发期间使用的、让程序在运行时进行自检的代码。断言为真，则表明程序运行正常，而断言为假，则意味着它已经在代码中发现了意料之外的错误。

- 用错误处理代码来处理预期会发生的情况，用断言来处理绝不应该发生的情况
- 避免把需要执行的代码放到断言中
- 用断言来注解并验证前条件和后条件
- 对于高健壮的代码，应该先使用断言再处理错误

<br/>
<br/>

## 错误处理技术

- 返回中立值
- 换用下一个正确的数据
- 返回与之前相同的数据
- 换用最接近的合法值
- 把警告信息记录到日志文件中
- 返回一个错误码
- 调用错误处理子程序或对象
- 当错误发生时显示出错消息
- 用最妥当的方式在局部处理错误
- 关闭程序
- 正确性和健壮性

<br/>
<br/>

## 异常

异常（exception），是把代码中的错误或异常事件传递给调用方代码的一种特殊手段。如果在一个子程序中遇到了意料之外的情况，但不知道如何处理的化，它就可以抛出一个异常。比如 `try-catch` 语句。

- 用异常通知程序的其他部分，发生了不可忽略的错误
- 只在真正例外的情况下才抛出异常
- 不能用异常来推卸责任
- 避免在构造函数和析构函数中抛出异常，除非你在同一地方把它们捕获
- 在恰当的抽象层次抛出异常
- 在异常消息中加入关于导致异常发生的全部信息
- 了解所用函数库可能抛出的异常
- 考虑创建一个集中的异常报告机制
- 把项目中对异常的使用标准化
- 考虑异常的替换方案

<br/>
<br/>

## 隔离程序以避免遭由错误造成的损害

<br/>
<br/>

## 辅助调试的代码

- 不要自动地把产品版的限制强加于开发版之上
- 尽早引入辅助调试的代码
- 采取进攻式编程
- 计划移除辅助调试的代码

<br/>
<br/>

## 确定在产品代码中该保留多少防御式代码

- 保留哪些检查重要错误的代码
- 去掉检查细微错误的代码
- 去掉可以导致程序硬性崩溃的代码
- 保留可以让程序稳妥地崩溃的代码
- 为你的技术支持人员记录错误信息
- 确认留在代码中的错误消息是友好的

<br/>
<br/>

## 对防御式编程采取防御的姿态

过度防御会使程序变得臃肿而缓慢，也增加了软件的复杂度。

<br/>

---

<br/>

# 伪代码的编程过程

伪代码编程过程（Pseudocode Programming Process, PPP），有助于减少设计和编写文档所需的工作量，同时提高这两项工作的质量。

<br/>
<br/>

## 创建类和子程序的步骤

创建类的步骤：

- 创建类的总体设计
- 创建类中子程序
- 复审并测试整个类

<br/>

创建子程序的步骤：

- 设计子程序
- 检查设计
- 复审并测试代码
- 编写子程序的代码

<br/>
<br/>

## 伪代码

伪代码这个术语，指某种用来描述算法、子程序、类或完整程序的工作逻辑的、非形式的、类似于英语的记法。

<br/>
<br/>

## 通过伪代码编程过程创建子程序

<br/>

### 设计子程序

- 检查先决条件
- 定义子程序要解决的问题
- 为子程序命名
- 决定如何测试子程序
- 在标准库中搜寻可用的功能
- 考虑错误处理
- 考虑效率问题
- 研究算法和数据类型
- 编写伪代码
- 考虑数据
- 检查伪代码

<br/>
<br/>

### 编写子程序的代码

- 写出子程序的声明
- 把伪代码转变为高层次的注释
- 在每条注释下填充代码
- 检查代码是否需要进一步分解
- 检查程序中的错误
- 编译子程序
- 在调试器中逐行执行代码
- 测试代码
- 消除程序中的错误

<br/>
<br/>

### 收尾工作

- 检查子程序的接口。
- 检查整体的设计质量。
- 检查子程序中的变量。
- 检查子程序的语句和逻辑。
- 检查子程序中的语句和逻辑。
- 检查子程序的布局。
- 检查子程序的文档。
- 出去冗余的注释。

<br/>
<br/>

## 伪代码编程过程之外的替代方案

- 测试开发先行
- 重构
- 契约式设计
- 东拼西凑

<br/>

---

<br/>

# 使用变量的一般事项

<br/>

## 数据认知

了解创建数据的类型。

<br/>
<br/>

## 变量定义

- 不建议使用隐式声明。
- 声明全部的变量。
- 遵循某种命名规则。
- 检查变量名。

<br/>
<br/>

## 变量初始化原则

- 在声明变量的时候初始化
- 在靠近变量第一次使用的位置初始化它
- 在靠近第一次使用变量的位置声明和定义该变量
- 在可能的情况下使用常量
- 特别注意计数器和累加器
- 在类的构造函数里初始化该类的数据成员
- 检查是否需要重新初始化
- 一次性初始化具名常量；用可执行代码来初始化变量
- 使用编译器设置来自动初始化所有变量
- 利用编译器的警告信息
- 检查输入参数的合法性
- 使用内存访问检查工具来检查错误的指针
- 在程序开始时初始化工作内存

<br/>
<br/>

## 变量的作用域

作用域（scope）或可见性（visibility），是指变量在程序内的可见和可引用的范围。

- 使变量引用局部化
- 尽可能缩短变量的存活时间

<br/>

减小作用域的一般原则：

- 在循环开始之前再去初始化该循环里使用的变量，而不是该循环所属的子程序的开始处初始化这些变量。
- 直到变量即将被使用时再为其赋值
- 把相关语句放到一起
- 把相关语句提取成单独的子程序
- 开始时采用最严格的可见性，然后根据需要扩展变量的作用域

<br/>
<br/>

## 持续性

持续性（persistence），是对一项数据的生命期的另一种描述。

- 特定代码段或子程序的生命期。
- 只要你允许，它就会持续下去。
- 程序的生命期。
- 永远持续。

<br/>
<br/>

## 绑定时间

绑定时间（binding time），把变量和它的值绑定在一起的时间。采用越晚的绑定时间会越有利。

一般而言，绑定时间越早灵活性就会越差，但复杂度也会越低。

变量与数值绑定的时间：

- 编码时
- 编译时
- 加载时
- 对象实例化时
- 即时

<br/>
<br/>

## 数据类型和控制结构之间的关系

- 序列型数据翻译为程序中的顺序语句
- 选择型数据翻译为程序中的 if、case 等语句
- 迭代型数据翻译成程序中的 for、while 等循环结构

<br/>
<br/>

## 为变量指定单一用途

- 每个变量只用于单一用途
- 避免让代码具有隐含含义
- 确保使用了所有已声明的变量

<br/>

---

<br/>

# 变量名的力量

<br/>

## 选择好变量名的注意事项

- 变量名要完全、准确地描述出该变量所代表的事物。
- 以问题为导向的的变量名称
- 适当的变量名称长度
- 变量名中常用的对仗词（如 opened/closed）

<br/>
<br/>

## 为特定类型的数据命名

<br/>
<br/>

### 为循环下标命名

简单的循环变量命名。

```java
// 简单的循环变量名: i, j, k
for ( i = firstItem; i < lastItem; i++ ) {
  ...
}
```

如果使用了多个嵌套循环，那么就该给循环变量赋予更长的名字，以提高可读性。

```java
for ( teamIndex = 0; teamIndex; teamCount; teamIndex++ ) {
  for ( eventIndex = 0; eventIndex < eventCount[teamIndex]; eventIndex++ ) {
    ...
  }
}
```

<br/>
<br/>

### 为状态变量命名

状态变量用于描述你的程序的状态。状态变量去一个比 flag 更好的名字。

<br/>
<br/>

### 为临时变量命名

临时变量用于存储计算的中间结果，作为临时占位符，以及存储内务管理值。

警惕临时变量，保存的一些值常常是很有必要的。

<br/>
<br/>

### 为布尔变量命名

一些典型的布尔变量名：

- done
- error
- found
- success/ok

使用肯定的布尔变量名。

<br/>
<br/>

### 为枚举类型命名

在使用枚举类型的时候，可通过使用组前缀（如 Color_（Color_Red, Color_Blue））来明确表示该类型的成员属于同一个组。

<br/>
<br/>

### 为常量命名

<br/>
<br/>

## 命名规则的力量

<br/>
<br/>

## 非正式命名规则

- 区分变量名和子程序名
- 区分类和对象
- 表示全局变量
- 标识成员变量
- 标识类型声明
- 标识具名常量
- 标识枚举类型的元素
- 在不能保证输入参数的只读的语言里标识只读参数
- 格式化命名以提高可读性

<br/>
<br/>

## 标准前缀

<br/>
<br/>

## 创建具有可读性的短名称

<br/>
<br/>

## 应该避免的名称

- 避免使用令人误解的名字或缩写
- 避免使用具有相似含义的名字
- 避免使用具有不同含义但却有相似名字的变量
- 避免在名字中使用数字
- 避免在名字中拼错单词
- 避免使用英语中常常拼错的单词
- 不仅要靠大小写来区分变量名
- 避免使用多种自然语言
- 避免使用标准类型、变量和子程序的名字
- 不要使用与变量含义完全无关的名字
- 避免在名字中包含易混淆的字符

<br/>

---

<br/>

# 基本数据类型

<br/>

## 数值概论

- 避免使用神秘数值
- 预防除零错误
- 使类型转换变得明显
- 避免混合类型的比较
- 注意编译器的警告

<br/>
<br/>

## 整数

- 检查整数除法（整数时，7/10 为 0，而不是 0.7）
- 检查整数溢出
- 检查中间结果溢出

| 整数类型 | 取值范围 |
| - | - |
| 有符号 8bit | -128 到 127 |
| 无符号 8bit | 0 到 255 |
| 有符号 16bit | -32 768 到 32 767 |
| 无符号 16bit | 0 到 65535 |
| 有符号 32bit | -2 147 483 648 到 2 147 483 647 |
| 无符号 32bit | 0 到 4 294 967 295 |

<br/>
<br/>

## 浮点数

- 避免数量级相差巨大的数之间的加减运算
- 避免等量判断
- 处理舍入误差问题
  - 精度问题
  - 进制问题
  - 浮点转整数问题
- 检查语言和函数库对特定数据类型的支持

<br/>
<br/>

## 字符和字符串

- 避免使用神秘字符和神秘字符串
- 避免 off-by-one 错误
- 了解语言和开发环境是如何支持 Unicode 的
- 在程序生命周期中尽早决定国际化/本地化策略
- 如果需要支持多语言，请使用 Unicode
- 采用某种一致的字符串类型转换策略

<br/>
<br/>

## 布尔变量

- 用布尔变量对程序加以文档说明
- 用布尔变量来简化复杂的判断
- 如有需要，创建自己的布尔类型

<br/>
<br/>

## 枚举类型

枚举类型是一种允许用英语来描述某一类对象中每一个成员的数据类型。

- 用枚举来提高可读性
- 用枚举来提高可靠性
- 用枚举来简化修改
- 将枚举作为布尔变量的替换方案
- 检查非法数值
- 把枚举的第一个元素留做非法值
- 警惕给枚举元素明确赋值而带来的失误

<br/>
<br/>

## 具名常量

具名常量很像变量，一旦赋值以后就不能再修改了。具名常量允许你用一个名字而不是数字，来表示固定的量（如员工人数的最大值）。

<br/>
<br/>

## 数组

数组中含有一组类型完全相同，并可用下标来直接访问的条目。

- 确认所有的数组下标都没有超出数组的边界
- 将数组作为顺序化结构来处理
- 检查数组的边界点
- 多维数组，确认下标的使用顺序是否正确

<br/>
<br/>

## 创建自己的数据类型

类型别名（Type Aliasing）

<br/>

---

<br/>

# 不常见的数据类型

<br/>

## 结构体

结构体（structure），指用其他类型组建的数据。

<br/>
<br/>

## 指针

指针（pointer），是现代编程最容易出错的领域之一。正确地使用指针要求对所用编译器的内存管理机制有很好的理解。很多常见的安全问题，特别是缓冲区溢出，其产生的问题都可追溯到错误地运用指针上去。

<br/>
<br/>

### 理解指针

- 内存中的位置（地址）。常用 16 进制表示。
- 指针所指的内容。

<br/>
<br/>

### 使用指针的技巧

通常，指针错误都产生于指针指向了它不应该指向的位置。当通过一个坏了的指针变量赋值时，会把数据写入本不该写值的内存区域。这称为 **内存破坏**。有时内存破坏会导致严重的系统崩溃；有时它会篡改程序其他部分的结果。因此，更正指针错误的大部分工作便是找出它的位置。

- 把指针操作限制在子程序或类里面
- 同时声明和定义指针
- 在于指针分配相同的作用域中删除指针
- 在使用指针之前检查指针
- 先检查指针所引用的变量再使用它
- 用狗牌字段（dog tag）来检测损毁的内存
- 增加明显的冗余
- 用额外的指针变量来提高代码的清晰度
- 简化复杂的指针表达式
- 画一个图
- 按照正确的顺序删除链表中的指针
- 分配一片保留的内存后备区域
- 粉碎垃圾数据
- 在删除或释放指针之后把它们设为空值
- 在删除变量之前检查非法指针
- 跟踪指针分配情况
- 采用非指针的技术

<br/>
<br/>

## 全局数据

全局数据可在程序中任意位置访问。

<br/>
<br/>

### 与全局数据有关的常见问题

- 无意间修改了全局数据
- 与全局数据有关的奇异的和令人激动的别名问题
- 与全局数据有关的代码重入问题
- 全局数据阻碍代码重用
- 与全局数据有关的非确定的初始化顺序事宜
- 全局数据破坏了模块化和智力上的可管理性

<br/>
<br/>

### 使用全局数据的理由

- 保存全局数值
- 模拟具名常量
- 模拟枚举类型
- 简化对极其常用的数据的使用
- 消除流浪数据

<br/>
<br/>

### 只有万不得已时才使用全局数据

- 首先把每个变量设置为局部的，仅当需要时才把变量设置为全局的。
- 区分全局变量和类变量。
- 使用访问器子程序。

<br/>
<br/>

### 使用访问器子程序来取代全局数据

全局数据能做的事情，都可以用访问器子程序做的更好。

<br/>
<br/>

### 如何降低使用全局数据的风险

- 创建一种命名规则来突出全局变量
- 为全部的全局变量创建一份注释良好的清单
- 不要用全局变量来存放中间结果
- 不要把所有的数据都放在一个大对象中并导出传递，以说明你没有使用全局变量

<br/>

---

<br/>

# 组织直线型代码

<br/>

## 必须有明确顺序的语句

- 设法组织代码，使依赖关系变得非常明显
- 使子程序名能突显依赖关系
- 利用子程序参数明确显示依赖关系
- 用注释对不清晰的依赖关系进行说明
- 用断言或错误处理来检查依赖关系

<br/>
<br/>

## 顺序无关的语句

- 使代码易于自上而下地阅读
- 把相关的语句组织在一起

<br/>

---

<br/>

# 使用条件语句

<br/>

## if语句

- 首先写正常代码路径；再处理不常见情况
- 确保对于等量的分支是正确的
- 把正常情况的处理放在 if 后面，而不要放在 else 后面
- 让 if 子句后面跟随一个有意义的语句
- 考虑 else 子句
- 测试 else 子句的正确性
- 检查 if 和 else 子句是不是弄反了

<br/>
<br/>

## case子句

- 为 case 选择最有效的排列顺序
- 简化每种情况对应的操作
- 不要为了使用 case 语句而刻意制造一个变量
- 把 default 子句只用于检查真正的默认情况
- 利用 default 子句来检测错误

<br/>

---

<br/>

# 控制循环

<br/>

## 循环的种类

- 计数循环：执行的次数是一定的。
- 连续求值的循环：预先并不知道将要执行多少次。
- 无限循环：一旦启动就会一直执行下去。
- 迭代器循环：对里面的每个元素执行一次操作。

<br/>
<br/>

### 什么时候使用while循环

如果预先并不知道循环要迭代多少次，那就使用 `while` 循环。

<br/>
<br/>

### 什么时候用带退出的循环

带退出的循环，就是终止条件出现在循环中间。

<br/>
<br/>

### 何时使用for循环

如果需要执行一个固定次数的循环，那么 `for` 循环是一个很好的选择。

<br/>
<br/>

### 何时使用foreach循环

`foreach` 循环适用于对数组或其他容器的各项元素执行操作。

<br/>
<br/>

## 循环控制

把控制尽可能地放到循环体外。应该把循环看作是一个黑盒子：外围程序只知道它的控制条件，却不知道它的内容。

<br/>
<br/>

### 进入循环

- 只能从一个位置进入循环
- 把初始化代码放在循环前面
- 用 `while(true)` 表示无限循环
- 在适当的情况下多使用 `for` 循环
- 在 while 循环更适用的时候，不要使用 for 循环

<br/>
<br/>

### 处理好循环体

- 把循环内务操作要么放在循环的开始，要么放在循环的末尾
- 一个循环只做一件事
- 没法确认循环能够终止
- 使循环终止条件看起来很明显
- 不要为了终止循环而胡乱改动 for 循环的下标
- 避免出现依赖于循环下标最终取值的代码
- 考虑使用安全计数器

<br/>
<br/>

### 提前退出循环

- 考虑在 while 循环中使用 break 语句而不是布尔标记
- 小心那些有很多 break 散布其中的循环
- 在循环开始处用 continue 进行判断
- 如果语言支持，请使用带标号的 break 结构（如Java: `break CALL_CENTER_DOWN`）
- 使用 break 和 continue 时要小心谨慎

<br/>
<br/>

### 检查端点

对于一个简单循环，通常需要注意三种情况：开始、任意选择的中间情况、最终。

<br/>
<br/>

### 使用循环变量

- 用整数或枚举类型表示数组和循环的边界
- 在嵌套循环中使用有意义的变量名来提高其可读性
- 用有意义的名字来避免循环下标串话（如在多个嵌套循环中使用相同的 i, j, k，应该避免）
- 把循环下标变量的作用域限制在本循环内

<br/>
<br/>

### 循环应该有多长

- 循环要尽可能地短，以便能够一目了然
- 把嵌套限制在 3 层以内
- 把长循环的内容移到子程序里
- 要让长循环格外清晰

<br/>
<br/>

## 轻松创建循环——由内而外

<br/>
<br/>

## 循环和数组的关系

很多情况下，循环就是用来操纵数组的，而且循环计数器和数组下标一一对应。

<br/>

---

<br/>

# 不常见的控制结构

<br/>

## 子程序中的多处返回

多数语言提供了某种半途退出子程序的方法（如 return 和 exit）。

- 如果能增加可读性，就使用 return。
- 用防卫子句来简化复杂的错误处理。
- 减少每个子程序 return 的数量。

<br/>
<br/>

## 递归

递归（recursion）里，一个子程序自己负责解决某个问题的一小部分，它还把问题分解成很多的小块，然后调用自己来分别解决每一小块。

对于某一小范围内的问题，使用递归会带来简单、优雅的解。在稍大一些范围里，使用递归会带来简单、优雅但难懂的解。对于大多数的问题，它所带来的解将会是机器复杂的——咋那些情况下，使用简单的迭代通常会比较容易理解。因此，要有选择地使用递归。

使用递归的技巧：

- 确认递归能够停止
- 使用安全计数器防止出现无穷递归
- 把递归限制在一个子程序内
- 留心栈空间
- 不要用递归去计算阶乘或斐波那契数列

<br/>
<br/>

## goto

几种替换 goto 的方法，有利有弊。

- 用嵌套的 if 语句重写
- 用一个状态变量重写
- 用 try-finally 重写

<br/>

---

<br/>

# 表驱动法

表驱动法（table-driven methods），是一种编程模式（scheme）——从表里查找信息而不使用逻辑语句。对简单的情况而言，使用逻辑语句更为容易和直白。但随着逻辑链的越来越复杂，查表法也就愈发显得更具吸引力。

<br/>

## 表驱动法使用总则

需要解决两个问题：

- 怎样从表中查询条目
  - 直接访问
  - 索引访问
  - 阶梯访问
- 应该在表里存些什么

<br/>

---

<br/>

# 一般控制问题

<br/>

## 布尔表达式

<br/>
<br/>

### 用true和false做布尔判断

在布尔表达式中，应该用 `true` 和 `false`，而不要用 `0` 和 `1` 等数值。

```sh
# 隐式地比较布尔值与 true 和 false。
while ( a > b)
# 而不是
while ( (a > b) = true )
```

<br/>
<br/>

### 简化复杂的表达式

- 拆分复杂的判断并引入新的布尔变量
- 把复杂的表达式做成布尔函数
- 用决策表代替复杂的条件

<br/>
<br/>

### 编写肯定形式的布尔表达式

- 在 if 语句中，把判断条件从否定形式转换为肯定形式。
- 用狄摩根定理简化否定的布尔判断

```java
// 否定型判断
if ( !displayOK || !printerOK)

// 应用狄摩根定理之后的判断
if ( !( displayOK && printerOK ) )
```

<br/>
<br/>

### 使用括号使布尔表达式更清晰

```java
if ( ( ( a < b ) == ( c == d ) ) && !done )
0  1 2 3       2    3        2 1          0

```

<br/>
<br/>

### 理解布尔表达式是如何求值的

<br/>
<br/>

### 按照数轴的顺序编写数值表达式

应该很好地组织数值判断，使其顺序与数轴上的点排列顺序相符。

<br/>
<br/>

### 与0比较的指导原则

- 隐式地比较逻辑变量
- 把数和 0 相比较
- 把指针与 NULL 相比较

<br/>
<br/>

### 布尔表达式的常见问题

- 在 C 家族语言中，应该把常量放在比较的左侧。
- 在 C++ 中，可以考虑创建预处理宏来替换 `&&`, `||` 和 `==`。
- 在 Java 中，应理解 `a==b`（是否引用了同一个对象）和 `a.equals(b)`（是否具有相同的值）之间的差异。

<br/>
<br/>

## 复合语句

- 把括号对一起写出
- 用括号把条件表达清楚

<br/>
<br/>

## 空语句

- 小心使用空语句
- 为空语句创建一个 `DoNothing()` 预处理宏或内联函数
- 考虑如果换用一个非空的循环体，是否会让代码更清晰

<br/>
<br/>

## 深层嵌套

- 避免使用超过 3 到 4 层的嵌套。
- 通过重复检测条件中的某一部分来简化嵌套的 if 语句。
- 用 break 块来简化嵌套 if
- 把嵌套 if 转换成一组 if-then-else 语句。
- 把嵌套 if 转换成 case 语句。
- 把深层嵌套的代码抽取出来放进单独的子程序。
- 使用一种更面向对象的方法。
- 重新设计深层嵌套的代码。

<br/>
<br/>

## 结构化编程

结构化编程的核心思想，一个应用程序应该只采用一些单入单出的控制结构。单入单出的控制结构指的是一个代码块，它只能从一个位置开始执行，并且只能结束于一个位置。

结构化编程的三个组成部分：

- 顺序（sequence）：按照先后顺序执行的语句。
- 选择（selection）：一种有选择的执行语句的控制结构。
- 迭代（iteration）：一种使一组语句多次执行的控制结构。

<br/>
<br/>

## 控制结构与复杂度

控制结构对程序整体的复杂度的影响非常大。将复杂度降低到最低水平是编写高质量代码的关键。

如何度量复杂度？

- 从 1 开始，一直往下通过程序。
- 一旦遇到某些关键字，就加 1：if, while, for 等。
- 给 case 语句中的每一个情况都加 1。
- 复杂度 6-10 得想办法简化子程序；复杂度大于 10 需要把子程序的某一部分拆分成另一个子程序并调用它。

<br/>

---

<br/>

# 软件质量概述


